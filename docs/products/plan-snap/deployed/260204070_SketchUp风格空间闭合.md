# SketchUpé£æ ¼ç©ºé—´é—­åˆç³»ç»Ÿ

> **æ—¶é—´ï¼š** 2026-02-04 07:00  
> **éœ€æ±‚ï¼š** ç»¿è™šçº¿å¯¹é½ + é»‘ç‚¹æç¤º + é¢å¡«å……é—­åˆ  
> **ä¼˜å…ˆçº§ï¼š** ğŸ”´ P0  
> **æ‰§è¡Œäººï¼š** CTO  
> **é¢„è®¡ï¼š** 2-3å¤©

---

## ğŸ“‹ CEOéœ€æ±‚

**CEOå–œæ¬¢çš„SketchUpæ‰‹æ„Ÿï¼š**
> "ç»¿è‰²è™šçº¿æé†’ä¸Šä¸‹çº¿å¯¹é½ï¼Œé»‘ç‚¹æé†’ä¸¤çº¿ç›¸äº¤ï¼Œå›¾å½¢é—­åˆåé¢œè‰²æé†’ã€‚"

**æ ¸å¿ƒä»·å€¼ï¼š**
- ä¸ç”¨æƒ³ï¼Œç³»ç»Ÿç”¨**é¢œè‰² + ç‚¹ + è™šçº¿**å‘Šè¯‰ç”¨æˆ·ï¼šå¯¹é½äº†/ç›¸äº¤äº†/é—­åˆäº†
- ç¬¦åˆcontractorç°åœºæ€ç»´
- æ¯”magicplanæ›´ç›´è§‚

---

## ğŸ¯ ä¸‰ç§å³æ—¶è§†è§‰åé¦ˆ

### 1ï¸âƒ£ ç»¿è‰²è™šçº¿ï¼šå¯¹é½æç¤º

**è§¦å‘ï¼š**
```
å½“å‰ç»˜åˆ¶ç‚¹çš„Xæˆ–Y
ä¸å·²æœ‰ç‚¹ï¼ˆendpoint/vertexï¼‰å¯¹é½ï¼ˆåœ¨å®¹å·®å†…ï¼‰
```

**è¡¨ç°ï¼š**
- ç»¿è‰²è™šçº¿
- ä»å½“å‰ç‚¹ â†’ å¯¹é½ç›®æ ‡ç‚¹
- åªåœ¨hover/dragæ—¶æ˜¾ç¤º
- **ä¸å¯é€‰ã€ä¸ä¿ç•™ã€ä¸æ˜¯çœŸguide**

**ç¤ºä¾‹ï¼š**
```
æ­£åœ¨ç”»çº¿ï¼Œé¼ æ ‡Yåæ ‡æ¥è¿‘å·²æœ‰ç‚¹çš„Y
â†’ å‡ºç°ç»¿è‰²æ¨ªè™šçº¿
â†’ æç¤º"ä½ å’Œé‚£ä¸ªç‚¹å¹³é½äº†"
```

---

### 2ï¸âƒ£ é»‘ç‚¹ï¼šå‘½ä¸­æç¤º

**è§¦å‘ï¼š**
```
é¼ æ ‡æ¥è¿‘ï¼š
- endpointï¼ˆç«¯ç‚¹ï¼‰
- intersectionï¼ˆäº¤ç‚¹ï¼‰
- onSegmentï¼ˆçº¿ä¸ŠæŠ•å½±ç‚¹ï¼‰
```

**è¡¨ç°ï¼š**
- å®å¿ƒé»‘ç‚¹ï¼ˆæˆ–é«˜å¯¹æ¯”è‰²ï¼‰
- æ¯”æ™®é€šç‚¹å¤§ä¸€åœˆ
- å¯snap

**è¯­ä¹‰ï¼š**
> "è¿™ä¸€ä¸‹ç‚¹ä¸‹å»æ˜¯'å‡†çš„'"

---

### 3ï¸âƒ£ é¢å¡«å……ï¼šé—­åˆæç¤º

**è§¦å‘ï¼š**
```
ä¸€ç»„çº¿å½¢æˆå®Œå…¨é—­åˆloop
æ— è‡ªäº¤
åœ¨åŒä¸€å¹³é¢
```

**è¡¨ç°ï¼š**
- è‡ªåŠ¨æ·¡è‰²å¡«å……ï¼ˆè“/ç°ï¼‰
- ä¸éœ€è¦ç¡®è®¤
- ä»£è¡¨"è¿™æ˜¯ä¸€ä¸ªç©ºé—´"

**æ³¨æ„ï¼š**
- âŒ ä¸æ˜¯å¢™
- âŒ ä¸æ˜¯slab
- âœ… åªæ˜¯ç©ºé—´è¯†åˆ«

---

## ğŸ”‘ å…³é”®åŒºåˆ†

### Alignment Guide â‰  Tape Guide

| ç±»å‹ | å¯ä¿ç•™ | ç”¨é€” |
|------|--------|------|
| Alignment Guideï¼ˆç»¿è™šçº¿ï¼‰ | âŒ | ç”»çº¿æ—¶å¯¹é½æç¤º |
| Tape Guideï¼ˆåç§»è¾…åŠ©çº¿ï¼‰ | âœ… | å®šä½/æ–½å·¥è¾…åŠ© |

### Face â‰  Room â‰  Wall

```
é—­åˆå¡«å…… â†’ åªä»£è¡¨"ç³»ç»Ÿè¯†åˆ«åˆ°enclosed area"
ä¸‹ä¸€æ­¥æ‰å¯èƒ½ â†’ æ ‡è®°ä¸ºRoom â†’ è®¡ç®—é¢ç§¯ â†’ è½¬æˆå¢™ä½“
```

---

## ğŸ¨ ç«¯ç‚¹æ˜¾ç¤ºè§„èŒƒï¼ˆSketchUpé£æ ¼ï¼‰

**CEOè¦æ±‚ï¼š**
> "å»æ‰ç©ºå¿ƒå°åœ†åœˆï¼Œåªåœ¨ç”»å›¾æ—¶ç”¨å®å¿ƒåœ†è¡¨ç¤ºæ¿€æ´»çŠ¶æ€ï¼ŒåƒSketchUpä¸€æ ·ã€‚"

### æ–°è§„åˆ™

**é»˜è®¤çŠ¶æ€ï¼ˆé™æ­¢ï¼‰ï¼š**
```
ä¸æ˜¾ç¤ºä»»ä½•ç«¯ç‚¹æ ‡è®°
ç”»é¢å¹²å‡€ï¼Œåªæœ‰çº¿å’Œé¢
```

**ç»˜åˆ¶ä¸­ï¼ˆline toolï¼‰ï¼š**
```
èµ·ç‚¹ï¼šå®å¿ƒç‚¹
æ¨æ–­ç‚¹ï¼šå®å¿ƒç‚¹ï¼ˆå‘½ä¸­æ—¶ï¼‰
é¢„è§ˆçº¿æœ«ç«¯ï¼šå°å®å¿ƒç‚¹
```

**é€‰ä¸­å¯¹è±¡ï¼ˆselect toolï¼‰ï¼š**
```
åªæœ‰è¢«é€‰ä¸­çš„segmentæ‰æ˜¾ç¤ºç«¯ç‚¹
ç«¯ç‚¹ä¸ºå®å¿ƒï¼ˆä¸è¦ç©ºå¿ƒï¼‰
hoveræ—¶æ”¾å¤§ä¸€åœˆ
```

**ç¼–è¾‘æ‹–æ‹½ä¸­ï¼š**
```
æ‹–æ‹½çš„ç«¯ç‚¹ï¼šå®å¿ƒé«˜äº®
å…¶ä»–ç«¯ç‚¹ï¼šä¸æ˜¾ç¤ºæˆ–æ·¡åŒ–
```

---

## ğŸ—ï¸ æŠ€æœ¯å®ç°

### æ•°æ®ç»“æ„

```typescript
// 1. Overlayç±»å‹ï¼ˆä¸è½åº“ï¼Œç¬æ—¶ï¼‰
type AlignmentGuide = {
  type: 'alignment'
  from: Pt
  to: Pt
  direction: 'horizontal' | 'vertical'
}

type InferencePoint = {
  type: 'inference'
  point: Pt
  kind: 'endpoint' | 'intersection' | 'onSegment'
}

type PreviewLine = {
  type: 'preview'
  from: Pt
  to: Pt
}

// 2. å®ä½“ç±»å‹ï¼ˆè½åº“ï¼‰
type Segment = {
  id: string
  kind: 'segment'
  a: Pt
  b: Pt
  // ... å…¶ä»–å±æ€§
}

type Face = {
  id: string
  kind: 'face'
  boundarySegmentIds: string[]  // é¡ºæ—¶é’ˆ
  polygon: Pt[]                  // ç¼“å­˜
  areaMm2: number               // ç¼“å­˜
  perimeterMm: number           // ç¼“å­˜
  bbox: Bounds
}

type Room = Face & {
  // Room Meta
  roomName?: string  // 'KITCHEN' | 'BATH' | ...
  level?: string     // 'BASEMENT' | 'MAIN' | 'UPPER'
  ceilingHeightMm?: number
  tags?: string[]    // 'existing' | 'new' | 'demo'
  notes?: string
}
```

---

### æ¸²æŸ“å±‚çº§ï¼ˆä»ä¸‹åˆ°ä¸Šï¼‰

```typescript
// æ¸²æŸ“é¡ºåºï¼ˆå¿…é¡»ï¼‰
const renderLayers = [
  'grid',                    // æœ€åº•å±‚
  'faces',                   // é¢å¡«å……
  'segments',                // çº¿æ®µ
  'guides',                  // Tape guidesï¼ˆå¦‚æœæ˜¾ç¤ºï¼‰
  'overlays',                // ç»¿è™šçº¿ + æ¨æ–­ç‚¹ + é¢„è§ˆçº¿
  'cursor'                   // æœ€é¡¶å±‚
]
```

**DoDï¼š**
- overlaysæ°¸è¿œåœ¨æœ€ä¸Šå±‚ï¼Œä¸è¢«çº¿é®æŒ¡

---

### 1. Alignmentå®ç°ï¼ˆç»¿è™šçº¿ï¼‰

```typescript
/**
 * å¯¹é½æ£€æµ‹
 * 
 * ä½¿ç”¨æ—¶æœºï¼šline toolæ‹–æ‹½æ—¶ï¼Œæ¯æ¬¡pointermove
 */
function detectAlignment(
  cursor: Pt,
  allPoints: Pt[],
  tolerancePx: number = 10
): AlignmentGuide | null {
  
  // 1. æ£€æŸ¥å‚ç›´å¯¹é½ï¼ˆXç›¸åŒï¼‰
  for (const point of allPoints) {
    const deltaX = Math.abs(cursor.x - point.x)
    const deltaXPx = deltaX * viewScale
    
    if (deltaXPx <= tolerancePx) {
      return {
        type: 'alignment',
        from: { x: point.x, y: Math.min(cursor.y, point.y) },
        to: { x: point.x, y: Math.max(cursor.y, point.y) },
        direction: 'vertical'
      }
    }
  }
  
  // 2. æ£€æŸ¥æ°´å¹³å¯¹é½ï¼ˆYç›¸åŒï¼‰
  for (const point of allPoints) {
    const deltaY = Math.abs(cursor.y - point.y)
    const deltaYPx = deltaY * viewScale
    
    if (deltaYPx <= tolerancePx) {
      return {
        type: 'alignment',
        from: { x: Math.min(cursor.x, point.x), y: point.y },
        to: { x: Math.max(cursor.x, point.x), y: point.y },
        direction: 'horizontal'
      }
    }
  }
  
  return null
}
```

**æ¸²æŸ“ï¼š**

```typescript
function renderAlignmentGuide(guide: AlignmentGuide, ctx: CanvasRenderingContext2D) {
  ctx.save()
  
  // ç»¿è‰²è™šçº¿
  ctx.strokeStyle = '#00ff00'
  ctx.lineWidth = 1
  ctx.setLineDash([5, 5])
  
  ctx.beginPath()
  ctx.moveTo(guide.from.x, guide.from.y)
  ctx.lineTo(guide.to.x, guide.to.y)
  ctx.stroke()
  
  ctx.restore()
}
```

---

### 2. Inference Pointå®ç°ï¼ˆå‘½ä¸­ç‚¹ï¼‰

```typescript
/**
 * æ¨æ–­ç‚¹æ£€æµ‹
 * 
 * æŒ‰ä¼˜å…ˆçº§æ£€æµ‹ï¼šendpoint > intersection > onSegment
 */
function detectInferencePoint(
  cursor: Pt,
  segments: Segment[],
  tolerancePx: number = 10
): InferencePoint | null {
  
  const worldTolerance = tolerancePx / viewScale
  
  // 1. æ£€æŸ¥ç«¯ç‚¹
  for (const seg of segments) {
    const distA = distance(cursor, seg.a)
    const distB = distance(cursor, seg.b)
    
    if (distA < worldTolerance) {
      return {
        type: 'inference',
        point: seg.a,
        kind: 'endpoint'
      }
    }
    
    if (distB < worldTolerance) {
      return {
        type: 'inference',
        point: seg.b,
        kind: 'endpoint'
      }
    }
  }
  
  // 2. æ£€æŸ¥äº¤ç‚¹
  for (let i = 0; i < segments.length; i++) {
    for (let j = i + 1; j < segments.length; j++) {
      const intersection = segmentIntersection(segments[i], segments[j])
      if (intersection.hit) {
        const dist = distance(cursor, intersection.point)
        if (dist < worldTolerance) {
          return {
            type: 'inference',
            point: intersection.point,
            kind: 'intersection'
          }
        }
      }
    }
  }
  
  // 3. æ£€æŸ¥çº¿ä¸ŠæŠ•å½±ç‚¹
  for (const seg of segments) {
    const proj = projectPointToSegment(cursor, seg)
    if (proj.onSegment) {
      const dist = distance(cursor, proj.point)
      if (dist < worldTolerance) {
        return {
          type: 'inference',
          point: proj.point,
          kind: 'onSegment'
        }
      }
    }
  }
  
  return null
}
```

**æ¸²æŸ“ï¼š**

```typescript
function renderInferencePoint(
  point: InferencePoint,
  ctx: CanvasRenderingContext2D
) {
  ctx.save()
  
  // å®å¿ƒé»‘ç‚¹
  ctx.fillStyle = '#000'
  
  // æ ¹æ®ç±»å‹è°ƒæ•´å¤§å°
  const radius = point.kind === 'endpoint' ? 6 : 4
  
  ctx.beginPath()
  ctx.arc(point.point.x, point.point.y, radius, 0, Math.PI * 2)
  ctx.fill()
  
  // å¯é€‰ï¼šæ˜¾ç¤ºlabel
  if (DEBUG) {
    ctx.fillStyle = '#666'
    ctx.font = '10px sans-serif'
    ctx.fillText(point.kind, point.point.x + 8, point.point.y - 8)
  }
  
  ctx.restore()
}
```

---

### 3. Face Closureå®ç°ï¼ˆé—­åˆæ£€æµ‹ï¼‰

```typescript
/**
 * é—­åˆæ£€æµ‹
 * 
 * æ¯æ¬¡æ·»åŠ /åˆ é™¤/ç§»åŠ¨segmentåè°ƒç”¨
 */
function detectFaces(segments: Segment[]): Face[] {
  const faces: Face[] = []
  
  // 1. æ„å»ºæ‹“æ‰‘å›¾
  const graph = buildGraph(segments)
  
  // 2. æŸ¥æ‰¾æ‰€æœ‰é—­åˆloop
  const loops = findClosedLoops(graph)
  
  // 3. è¿‡æ»¤ç®€å•å¤šè¾¹å½¢ï¼ˆæ— è‡ªäº¤ï¼‰
  const simpleLoops = loops.filter(loop => isSimplePolygon(loop))
  
  // 4. åˆ›å»ºFaceå¯¹è±¡
  for (const loop of simpleLoops) {
    const polygon = loop.map(segId => segments.find(s => s.id === segId))
    const points = polygonToPoints(polygon)
    
    faces.push({
      id: generateId(),
      kind: 'face',
      boundarySegmentIds: loop,
      polygon: points,
      areaMm2: calculateArea(points),
      perimeterMm: calculatePerimeter(points),
      bbox: calculateBounds(points)
    })
  }
  
  return faces
}

/**
 * æ„å»ºæ‹“æ‰‘å›¾
 */
function buildGraph(segments: Segment[]): Map<string, string[]> {
  const graph = new Map<string, string[]>()
  
  for (const seg of segments) {
    const keyA = pointToKey(seg.a)
    const keyB = pointToKey(seg.b)
    
    if (!graph.has(keyA)) graph.set(keyA, [])
    if (!graph.has(keyB)) graph.set(keyB, [])
    
    graph.get(keyA)!.push(seg.id)
    graph.get(keyB)!.push(seg.id)
  }
  
  return graph
}

/**
 * æŸ¥æ‰¾é—­åˆloopï¼ˆæ·±åº¦ä¼˜å…ˆæœç´¢ï¼‰
 */
function findClosedLoops(graph: Map<string, string[]>): string[][] {
  const loops: string[][] = []
  const visited = new Set<string>()
  
  function dfs(current: string, path: string[], start: string) {
    if (path.length > 0 && current === start) {
      loops.push([...path])
      return
    }
    
    if (visited.has(current) || path.length > 20) return
    
    visited.add(current)
    const neighbors = graph.get(current) || []
    
    for (const neighbor of neighbors) {
      if (!path.includes(neighbor)) {
        dfs(neighbor, [...path, neighbor], start)
      }
    }
    
    visited.delete(current)
  }
  
  for (const node of graph.keys()) {
    dfs(node, [], node)
  }
  
  return loops
}

/**
 * æ£€æŸ¥æ˜¯å¦ä¸ºç®€å•å¤šè¾¹å½¢ï¼ˆæ— è‡ªäº¤ï¼‰
 */
function isSimplePolygon(loop: string[]): boolean {
  // å®ç°ç•¥ï¼ˆæ£€æŸ¥è¾¹æ˜¯å¦ç›¸äº¤ï¼‰
  return true  // ç®€åŒ–ç‰ˆ
}
```

**æ¸²æŸ“ï¼š**

```typescript
function renderFace(face: Face, ctx: CanvasRenderingContext2D) {
  ctx.save()
  
  // æ·¡è“è‰²å¡«å……
  ctx.fillStyle = 'rgba(173, 216, 230, 0.3)'
  
  ctx.beginPath()
  ctx.moveTo(face.polygon[0].x, face.polygon[0].y)
  for (let i = 1; i < face.polygon.length; i++) {
    ctx.lineTo(face.polygon[i].x, face.polygon[i].y)
  }
  ctx.closePath()
  ctx.fill()
  
  ctx.restore()
}
```

---

### 4. ç«¯ç‚¹æ˜¾ç¤ºå®ç°

```typescript
/**
 * ç«¯ç‚¹æ¸²æŸ“æ§åˆ¶
 */
function renderEndpoints(
  segments: Segment[],
  selectedIds: Set<string>,
  toolState: ToolState,
  ctx: CanvasRenderingContext2D
) {
  // 1. é»˜è®¤çŠ¶æ€ï¼šä¸æ˜¾ç¤ºä»»ä½•ç«¯ç‚¹
  if (toolState.tool === 'select' && selectedIds.size === 0) {
    return
  }
  
  // 2. ç»˜åˆ¶ä¸­ï¼šåªæ˜¾ç¤ºèµ·ç‚¹
  if (toolState.tool === 'line' && toolState.phase === 'drawing') {
    if (toolState.startPoint) {
      renderSolidPoint(toolState.startPoint, ctx, '#000', 5)
    }
    return
  }
  
  // 3. é€‰ä¸­çŠ¶æ€ï¼šæ˜¾ç¤ºé€‰ä¸­segmentçš„ç«¯ç‚¹
  if (toolState.tool === 'select') {
    for (const seg of segments) {
      if (selectedIds.has(seg.id)) {
        renderSolidPoint(seg.a, ctx, '#000', 5)
        renderSolidPoint(seg.b, ctx, '#000', 5)
      }
    }
  }
}

/**
 * æ¸²æŸ“å®å¿ƒç‚¹
 */
function renderSolidPoint(
  point: Pt,
  ctx: CanvasRenderingContext2D,
  color: string = '#000',
  radius: number = 5
) {
  ctx.save()
  ctx.fillStyle = color
  ctx.beginPath()
  ctx.arc(point.x, point.y, radius, 0, Math.PI * 2)
  ctx.fill()
  ctx.restore()
}

/**
 * hoveræ”¾å¤§æ•ˆæœ
 */
function renderHoverEndpoint(
  point: Pt,
  ctx: CanvasRenderingContext2D
) {
  // å¤–åœˆ
  ctx.save()
  ctx.strokeStyle = '#0066ff'
  ctx.lineWidth = 2
  ctx.beginPath()
  ctx.arc(point.x, point.y, 8, 0, Math.PI * 2)
  ctx.stroke()
  ctx.restore()
  
  // å†…æ ¸
  renderSolidPoint(point, ctx, '#000', 5)
}
```

---

### 5. æ€§èƒ½ä¼˜åŒ–ï¼ˆç©ºé—´ç´¢å¼•ï¼‰

```typescript
/**
 * ç©ºé—´ç´¢å¼•ï¼ˆé˜²æ­¢è¶Šç”¨è¶Šæ…¢ï¼‰
 * 
 * ç”¨äºå¿«é€ŸæŸ¥æ‰¾ï¼š
 * - é™„è¿‘çš„ç‚¹ï¼ˆendpointæ£€æµ‹ï¼‰
 * - é™„è¿‘çš„çº¿ï¼ˆintersectionæ£€æµ‹ï¼‰
 */
class SpatialIndex {
  private grid: Map<string, Segment[]> = new Map()
  private cellSize: number
  
  constructor(cellSize: number = 100) {
    this.cellSize = cellSize
  }
  
  insert(segment: Segment) {
    const cells = this.getCellsForSegment(segment)
    for (const cell of cells) {
      if (!this.grid.has(cell)) {
        this.grid.set(cell, [])
      }
      this.grid.get(cell)!.push(segment)
    }
  }
  
  queryPoint(point: Pt, radius: number): Segment[] {
    const bounds = {
      min: { x: point.x - radius, y: point.y - radius },
      max: { x: point.x + radius, y: point.y + radius }
    }
    
    const cells = this.getCellsForBounds(bounds)
    const results = new Set<Segment>()
    
    for (const cell of cells) {
      const segs = this.grid.get(cell)
      if (segs) {
        segs.forEach(s => results.add(s))
      }
    }
    
    return Array.from(results)
  }
  
  private getCellsForSegment(seg: Segment): string[] {
    const bounds = {
      min: {
        x: Math.min(seg.a.x, seg.b.x),
        y: Math.min(seg.a.y, seg.b.y)
      },
      max: {
        x: Math.max(seg.a.x, seg.b.x),
        y: Math.max(seg.a.y, seg.b.y)
      }
    }
    return this.getCellsForBounds(bounds)
  }
  
  private getCellsForBounds(bounds: Bounds): string[] {
    const minX = Math.floor(bounds.min.x / this.cellSize)
    const maxX = Math.floor(bounds.max.x / this.cellSize)
    const minY = Math.floor(bounds.min.y / this.cellSize)
    const maxY = Math.floor(bounds.max.y / this.cellSize)
    
    const cells: string[] = []
    for (let x = minX; x <= maxX; x++) {
      for (let y = minY; y <= maxY; y++) {
        cells.push(`${x},${y}`)
      }
    }
    return cells
  }
}
```

**ä½¿ç”¨ï¼š**

```typescript
// åˆå§‹åŒ–
const spatialIndex = new SpatialIndex(100)

// æ¯æ¬¡segmentså˜åŒ–æ—¶é‡å»º
function onSegmentsChanged(segments: Segment[]) {
  spatialIndex.clear()
  segments.forEach(s => spatialIndex.insert(s))
}

// pointermoveæ—¶ä½¿ç”¨
function onPointerMove(cursor: Pt) {
  // åªæŸ¥è¯¢é™„è¿‘çš„segments
  const nearby = spatialIndex.queryPoint(cursor, 20)
  const inference = detectInferencePoint(cursor, nearby)
  // ...
}
```

---

## ğŸ® å®Œæ•´ä½¿ç”¨æµç¨‹

### LineTool with Inference

```typescript
class LineToolWithInference {
  private startPoint: Pt | null = null
  private spatialIndex: SpatialIndex
  
  constructor(spatialIndex: SpatialIndex) {
    this.spatialIndex = spatialIndex
  }
  
  onPointerMove(cursor: Pt, segments: Segment[]) {
    const overlays: any[] = []
    
    // 1. æ¨æ–­ç‚¹æ£€æµ‹
    const nearby = this.spatialIndex.queryPoint(cursor, 20)
    const inference = detectInferencePoint(cursor, nearby)
    if (inference) {
      overlays.push(inference)
    }
    
    // 2. å¯¹é½æ£€æµ‹
    if (this.startPoint) {
      const allPoints = this.getAllPoints(segments)
      const alignment = detectAlignment(cursor, allPoints)
      if (alignment) {
        overlays.push(alignment)
      }
      
      // 3. é¢„è§ˆçº¿
      overlays.push({
        type: 'preview',
        from: this.startPoint,
        to: inference?.point || cursor
      })
    }
    
    return overlays
  }
  
  onPointerDown(cursor: Pt, inference: InferencePoint | null) {
    const point = inference?.point || cursor
    
    if (!this.startPoint) {
      this.startPoint = point
    } else {
      // åˆ›å»ºsegment
      const segment = {
        id: generateId(),
        kind: 'segment',
        a: this.startPoint,
        b: point
      }
      
      // æ·»åŠ åˆ°segments
      addSegment(segment)
      
      // æ£€æµ‹é—­åˆ
      const faces = detectFaces(getAllSegments())
      updateFaces(faces)
      
      // é‡ç½®
      this.startPoint = null
    }
  }
  
  private getAllPoints(segments: Segment[]): Pt[] {
    const points: Pt[] = []
    for (const seg of segments) {
      points.push(seg.a, seg.b)
    }
    return points
  }
}
```

---

## âœ… éªŒæ”¶æ ‡å‡†ï¼ˆDoDï¼‰

### åŠŸèƒ½DoD

- [ ] **ç»¿è™šçº¿å¯¹é½**
  - å‚ç›´/æ°´å¹³å¯¹é½æ—¶å‡ºç°
  - åªåœ¨æ‹–æ‹½æ—¶æ˜¾ç¤º
  - æ¾å¼€ç«‹å³æ¶ˆå¤±

- [ ] **å®å¿ƒç‚¹æ¨æ–­**
  - endpointã€intersectionã€onSegmentéƒ½èƒ½è¯†åˆ«
  - è·ç¦»å®¹å·®10pxå·¦å³
  - ç‚¹å‡»æ—¶snapåˆ°æ¨æ–­ç‚¹

- [ ] **é¢é—­åˆå¡«å……**
  - é—­åˆloopè‡ªåŠ¨è¯†åˆ«
  - æ·¡è‰²å¡«å……å®æ—¶å‡ºç°
  - åˆ é™¤çº¿æ—¶å¡«å……æ¶ˆå¤±

- [ ] **ç«¯ç‚¹æ˜¾ç¤º**
  - é™æ­¢æ—¶ä¸æ˜¾ç¤ºç«¯ç‚¹
  - ç»˜åˆ¶ä¸­åªæ˜¾ç¤ºèµ·ç‚¹ï¼ˆå®å¿ƒï¼‰
  - é€‰ä¸­æ—¶æ˜¾ç¤ºç«¯ç‚¹ï¼ˆå®å¿ƒï¼‰
  - hoveræ—¶æ”¾å¤§ä¸€åœˆ

---

### æ€§èƒ½DoD

- [ ] **inferenceè®¡ç®— < 5ms**
  - ä½¿ç”¨ç©ºé—´ç´¢å¼•
  - ä¸å…¨å›¾æ‰«æ

- [ ] **Faceæ£€æµ‹ < 50ms**
  - æ™®é€šæˆ·å‹ï¼ˆ20-30æ¡çº¿ï¼‰
  - å¢é‡æ›´æ–°

- [ ] **æ¸²æŸ“æµç•…**
  - overlayså•ç‹¬layer
  - requestAnimationFrameèŠ‚æµ

---

### è§†è§‰DoD

- [ ] **æ¸²æŸ“å±‚çº§æ­£ç¡®**
  - overlaysåœ¨æœ€ä¸Šå±‚
  - ä¸è¢«çº¿é®æŒ¡

- [ ] **é¢œè‰²å¯¹æ¯”æ¸…æ™°**
  - ç»¿è™šçº¿å¯è§
  - é»‘ç‚¹é«˜å¯¹æ¯”
  - é¢å¡«å……ä¸æŠ¢çœ¼

---

## ğŸ§ª æµ‹è¯•ç”¨ä¾‹

### TC-1: å¯¹é½æç¤º

```
1. ç”»ç¬¬ä¸€æ¡çº¿ï¼ˆæ°´å¹³ï¼‰
2. å¼€å§‹ç”»ç¬¬äºŒæ¡çº¿
3. ç§»åŠ¨é¼ æ ‡åˆ°ä¸ç¬¬ä¸€æ¡çº¿Yåæ ‡æ¥è¿‘

æœŸæœ›ï¼š
- å‡ºç°ç»¿è‰²æ¨ªè™šçº¿
- è¿æ¥å½“å‰ç‚¹å’Œç¬¬ä¸€æ¡çº¿
```

---

### TC-2: ç«¯ç‚¹æ¨æ–­

```
1. ç”»ä¸¤æ¡ç›¸äº¤çš„çº¿
2. å¼€å§‹ç”»ç¬¬ä¸‰æ¡çº¿
3. é¼ æ ‡ç§»åˆ°äº¤ç‚¹é™„è¿‘

æœŸæœ›ï¼š
- å‡ºç°å®å¿ƒé»‘ç‚¹
- ç‚¹å‡»æ—¶snapåˆ°äº¤ç‚¹
```

---

### TC-3: é—­åˆå¡«å……

```
1. ç”»ä¸‰æ¡çº¿å½¢æˆä¸‰è§’å½¢
2. ç”»ç¬¬å››æ¡çº¿é—­åˆ

æœŸæœ›ï¼š
- æœ€åä¸€æ¡çº¿é—­åˆæ—¶ï¼Œç«‹å³å‡ºç°æ·¡è‰²å¡«å……
- å¡«å……è¦†ç›–æ•´ä¸ªä¸‰è§’å½¢åŒºåŸŸ
```

---

### TC-4: ç«¯ç‚¹æ˜¾ç¤º

```
1. ç”»ä¸€æ¡çº¿
2. ä¸é€‰ä¸­ï¼Œè§‚å¯Ÿç”»é¢

æœŸæœ›ï¼š
- ä¸æ˜¾ç¤ºä»»ä½•ç«¯ç‚¹
- ç”»é¢å¹²å‡€

3. é€‰ä¸­è¿™æ¡çº¿

æœŸæœ›ï¼š
- ä¸¤ç«¯å‡ºç°å®å¿ƒç‚¹
- hoveræ—¶æ”¾å¤§
```

---

## ğŸ“ Roomå¯¹è±¡æ‰©å±•ï¼ˆPhase 2ï¼‰

**å½“ç”¨æˆ·ç‚¹å‡»Faceåï¼š**

```typescript
function onFaceClick(face: Face) {
  // å°†Faceè½¬ä¸ºRoom
  const room: Room = {
    ...face,
    roomName: undefined,  // å¾…ç”¨æˆ·è¾“å…¥
    level: 'MAIN',
    ceilingHeightMm: 2400,
    tags: [],
    notes: ''
  }
  
  // æ˜¾ç¤ºç¼–è¾‘é¢æ¿
  showRoomEditPanel(room)
}
```

**Roomç¼–è¾‘é¢æ¿ï¼š**

```tsx
function RoomEditPanel({ room, onSave }: { room: Room, onSave: (r: Room) => void }) {
  const [name, setName] = useState(room.roomName || '')
  const [height, setHeight] = useState(room.ceilingHeightMm || 2400)
  
  return (
    <div className="room-edit-panel">
      <h3>Room Properties</h3>
      
      <label>
        Room Name:
        <select value={name} onChange={e => setName(e.target.value)}>
          <option value="">Select...</option>
          <option value="KITCHEN">Kitchen</option>
          <option value="BATH">Bathroom</option>
          <option value="BEDROOM">Bedroom</option>
          <option value="LIVING">Living Room</option>
        </select>
      </label>
      
      <label>
        Ceiling Height:
        <input 
          type="text" 
          value={formatLength(height)} 
          onChange={e => setHeight(parseLengthToMM(e.target.value))}
        />
      </label>
      
      <label>
        Area: {(room.areaMm2 / 1000000).toFixed(2)} mÂ²
      </label>
      
      <button onClick={() => onSave({ ...room, roomName: name, ceilingHeightMm: height })}>
        Save
      </button>
    </div>
  )
}
```

---

## ğŸš€ æ‰§è¡Œè®¡åˆ’

### Day 1: InferenceåŸºç¡€ï¼ˆ6å°æ—¶ï¼‰

- [ ] SpatialIndexå®ç°
- [ ] detectInferencePointå®ç°
- [ ] detectAlignmentå®ç°
- [ ] overlayæ¸²æŸ“

---

### Day 2: Faceæ£€æµ‹ï¼ˆ6å°æ—¶ï¼‰

- [ ] æ‹“æ‰‘å›¾æ„å»º
- [ ] é—­åˆloopæŸ¥æ‰¾
- [ ] Faceå¯¹è±¡ç”Ÿæˆ
- [ ] å¡«å……æ¸²æŸ“

---

### Day 3: ç«¯ç‚¹+ä¼˜åŒ–ï¼ˆ4å°æ—¶ï¼‰

- [ ] ç«¯ç‚¹æ˜¾ç¤ºè§„åˆ™
- [ ] hoveräº¤äº’
- [ ] æ€§èƒ½ä¼˜åŒ–
- [ ] å®Œæ•´æµ‹è¯•

---

**æ‰§è¡Œäººï¼š** CTO  
**é¢„è®¡å®Œæˆï¼š** 2-3å¤©  
**éªŒæ”¶äººï¼š** CEO

---

è¿™ä¸ªç³»ç»Ÿä¼šè®©PlanSnapçš„ç”»å›¾æ‰‹æ„Ÿæ¥è¿‘SketchUpï¼Œcontractorä¼šéå¸¸å–œæ¬¢ï¼ğŸ¯
