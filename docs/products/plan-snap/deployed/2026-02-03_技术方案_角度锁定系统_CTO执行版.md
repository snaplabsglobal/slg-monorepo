# PlanSnap 角度锁定系统技术方案

> **文档类型：** 技术方案 - CTO执行版  
> **创建日期：** 2026-02-03  
> **优先级：** 🔴 P0 - Critical（阻塞专业体验）  
> **预计工作量：** 3-4天  
> **状态：** ⏳ 待开始

---

## 📋 执行摘要

### 问题本质

**当前痛点：**
```
用户画"竖线" → 实际是 89° 或 91°
Grid 很密，但鼠标微抖就偏了
结果：视觉不直、累积误差、强迫症爆炸
```

**用户原话：**
> "我最讨厌线条无规则乱画"

### 解决方案

**必须支持：** 角度锁定 / 角度吸附（Angle Lock / Angle Snap）  
**设计原则：** 默认就好用，不用点菜单  
**目标：** 从 magicplan 跨到 AutoCAD / SketchUp 的关键一跃

---

## 🎯 产品需求

### 核心需求（CPO明确要求）

1. **默认智能角度吸附** - 无需按键，自动工作
2. **Shift强制正交** - 行业标准肌肉记忆
3. **可选高级角度** - 支持但不默认污染体验

### 验收标准（CPO口径）

**交互验收：**
> "用户拉'竖线'时，鼠标一靠近90°，系统自动锁定，永远是正直线，不管grid多密、zoom多大。"

**产品验收：**
> "我不希望任何线在没有明确意图的情况下出现 89° 或 91°。默认必须吸附到 30/45/60/90，Shift 强制正交。"

---

## 🏗️ 技术方案

### 一、角度锁定的三个层级

#### ① 默认智能角度吸附（最重要）⭐⭐⭐

**默认吸附角度集（architectural）：**
```typescript
const ARCHITECTURAL_ANGLES = [
  0,    // 水平
  30,   // 工程常用
  45,   // 对角
  60,   // 工程常用
  90,   // 垂直
  120,  // 镜像
  135,  // 镜像
  150,  // 镜像
  180,  // 水平反向
  270   // 垂直反向
]
```

**角度容差（非常关键）：**
```
±2° ~ ±3°（推荐 3°）
超过才算自由角度
```

**工作原理：**
- 鼠标靠近这些角度 → 自动吸附
- 不需要 grid
- 不需要输入
- 不需要任何手动操作

---

#### ② Shift = 强制正交（行业标准）

**功能：**
```
按住 Shift → 永远只画水平或垂直
```

**优先级：**
```
Shift 正交 > 所有其他角度吸附
```

**参考实现：**
- AutoCAD 的 Ortho 模式
- SketchUp 的 Shift 锁定

---

#### ③ 显式 Angle Lock（高级但很爽）

**功能：**
```
按 A → 循环切换角度集：
  - Basic (0°/90°)
  - Standard (0°/45°/90°)
  - Architectural (0°/30°/45°/60°/90°)
  - Advanced (包含 22.5°)
```

**适用场景：**
- 斜墙
- ISO结构
- 特殊角度需求

---

### 二、角度锁定优先级（非常重要）

CTO 必须按这个顺序实现：

```
1. Typed Length (用户明确输入)
   ↓
2. Explicit Angle Lock (A键 / UI)
   ↓
3. Inference (parallel / perpendicular)
   ↓
4. Smart Angle Snap (30/45/60/90)
   ↓
5. Shift Ortho
   ↓
6. Free Angle
```

**关键规则：**
```
Angle Snap 优先于 Grid
Grid 永远不决定角度
```

---

### 三、几何实现（核心逻辑）

#### 1️⃣ 计算当前角度

```typescript
const v = {
  x: end.x - start.x,
  y: end.y - start.y
}
const angle = Math.atan2(v.y, v.x) // 弧度
```

---

#### 2️⃣ 定义可吸附角度（弧度）

```typescript
const SNAP_ANGLES_RAD = [
  0,                    // 0°
  Math.PI / 6,          // 30°
  Math.PI / 4,          // 45°
  Math.PI / 3,          // 60°
  Math.PI / 2,          // 90°
  2 * Math.PI / 3,      // 120°
  3 * Math.PI / 4,      // 135°
  5 * Math.PI / 6,      // 150°
  Math.PI,              // 180°
  3 * Math.PI / 2       // 270°
]
```

**扩展规则：**
```typescript
// 自动生成镜像角度
function generateFullAngleSet(baseAngles: number[]): number[] {
  const full = new Set<number>()
  for (const a of baseAngles) {
    full.add(a)
    full.add(Math.PI - a)      // 镜像
    full.add(Math.PI + a)      // 反向
    full.add(2 * Math.PI - a)  // 360° 镜像
  }
  return Array.from(full).sort()
}
```

---

#### 3️⃣ 找最近角度

```typescript
interface SnapResult {
  snappedAngle: number | null
  distance: number
}

function snapAngle(
  theta: number, 
  toleranceDeg: number = 3
): SnapResult {
  const tol = toleranceDeg * Math.PI / 180
  let bestAngle: number | null = null
  let minDistance = Infinity

  for (const snapAngle of SNAP_ANGLES_RAD) {
    // 处理周期性（0° 和 360° 等价）
    const d = Math.min(
      Math.abs(theta - snapAngle),
      Math.abs(theta - snapAngle + 2 * Math.PI),
      Math.abs(theta - snapAngle - 2 * Math.PI)
    )
    
    if (d < minDistance && d <= tol) {
      minDistance = d
      bestAngle = snapAngle
    }
  }

  return {
    snappedAngle: bestAngle,
    distance: minDistance
  }
}
```

---

#### 4️⃣ 应用角度锁定

```typescript
function applyAngleSnap(
  start: Vec2, 
  end: Vec2, 
  options: {
    shiftPressed: boolean
    currentAngleLock?: number
    tolerance?: number
  }
): Vec2 {
  const v = { x: end.x - start.x, y: end.y - start.y }
  const len = Math.sqrt(v.x * v.x + v.y * v.y)
  const angle = Math.atan2(v.y, v.x)
  
  let finalAngle = angle
  
  // 优先级 1: Shift 强制正交
  if (options.shiftPressed) {
    const angles = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2]
    const { snappedAngle } = snapAngle(angle, 90) // 大容差
    finalAngle = snappedAngle ?? angle
  }
  // 优先级 2: 显式角度锁定
  else if (options.currentAngleLock !== undefined) {
    finalAngle = options.currentAngleLock
  }
  // 优先级 3: 智能角度吸附
  else {
    const { snappedAngle } = snapAngle(angle, options.tolerance ?? 3)
    if (snappedAngle !== null) {
      finalAngle = snappedAngle
    }
  }
  
  // 应用角度
  return {
    x: start.x + len * Math.cos(finalAngle),
    y: start.y + len * Math.sin(finalAngle)
  }
}
```

---

### 四、UI 反馈（必须实现）

**问题：**
```
角度被锁了，一定要告诉用户
否则用户会以为是 bug
```

#### 推荐反馈方式

**1. 角度文字提示（推荐）**
```
显示位置：鼠标光标旁边
显示内容：
  ⟂ 90°
  ↗ 45°
  ↖ 135°
  
样式：
  - 半透明背景
  - 白色文字
  - 小号字体（12px）
```

**2. 状态栏文字**
```
显示位置：画布底部状态栏
显示内容：
  "Angle snap: 90°"
  "Shift: Ortho mode"
  "Free angle: 89.3°"
```

**3. 视觉高亮（可选）**
```
当角度吸附时：
  - 线条轻微高亮
  - 或显示虚线预览
  - 或端点颜色变化
```

---

### 五、角度集配置系统

#### 预定义角度集

```typescript
const ANGLE_SETS = {
  basic: {
    name: 'Basic',
    angles: [0, 90], // 度数
    description: '仅水平和垂直'
  },
  
  standard: {
    name: 'Standard',
    angles: [0, 45, 90],
    description: '水平、垂直、对角'
  },
  
  architectural: {
    name: 'Architectural',
    angles: [0, 30, 45, 60, 90],
    description: '建筑常用角度（默认）'
  },
  
  advanced: {
    name: 'Advanced',
    angles: [0, 22.5, 30, 45, 60, 90],
    description: '包含 22.5° 高级角度'
  }
}
```

#### 默认配置

```typescript
const DEFAULT_ANGLE_SET = 'architectural'
const DEFAULT_TOLERANCE = 3 // 度数
```

---

### 六、与现有系统的集成

#### 与 Inference Engine 的关系

```typescript
// 优先级顺序
function computeFinalPosition(
  start: Vec2,
  mousePos: Vec2,
  context: {
    typedLength?: number
    explicitAngleLock?: number
    inferredPoint?: Vec2
    shiftPressed: boolean
  }
): Vec2 {
  // 1. 用户明确输入长度
  if (context.typedLength !== undefined) {
    const angle = Math.atan2(
      mousePos.y - start.y, 
      mousePos.x - start.x
    )
    const snappedAngle = applyAngleSnap(
      start, 
      mousePos, 
      { shiftPressed: context.shiftPressed }
    )
    // ... 应用长度和角度
  }
  
  // 2. Inference 推断点
  if (context.inferredPoint) {
    return context.inferredPoint
  }
  
  // 3. 角度吸附
  return applyAngleSnap(start, mousePos, {
    shiftPressed: context.shiftPressed,
    currentAngleLock: context.explicitAngleLock
  })
}
```

---

#### 与 Grid 的关系

```
Grid ≠ 角度约束
Grid 只是视觉参考
角度吸附独立工作
```

**关键：**
```typescript
// ❌ 错误：让 Grid 决定角度
const snappedToGrid = snapToGrid(end)

// ✅ 正确：先角度，再 Grid
const angleSnapped = applyAngleSnap(start, end, options)
const finalPos = snapToGrid(angleSnapped) // 可选
```

---

## 🧪 测试用例

### 基础测试

#### Test 1: 默认角度吸附
```
输入：
  - 起点 (0, 0)
  - 终点 (100, 2)  // 接近水平但微偏
  
期望：
  - 吸附到 0°
  - 终点变为 (100, 0)
  - 显示 "→ 0°"
```

#### Test 2: Shift 强制正交
```
输入：
  - 起点 (0, 0)
  - 终点 (100, 50)
  - Shift 按下
  
期望：
  - 吸附到 0° 或 90°（选最近的）
  - 如果 angle < 45° → 0°
  - 如果 angle >= 45° → 90°
```

#### Test 3: 45° 吸附
```
输入：
  - 起点 (0, 0)
  - 终点 (100, 98)  // 接近 45°
  
期望：
  - 吸附到 45°
  - 终点变为 (100, 100)
  - 显示 "↗ 45°"
```

---

### 边界测试

#### Test 4: 容差边界
```
输入：
  - 目标角度 90°
  - 实际角度 93°（超过 3° 容差）
  
期望：
  - 不吸附
  - 保持 93°
  - 显示 "Free: 93°"
```

#### Test 5: 周期性处理
```
输入：
  - 起点 (100, 100)
  - 终点 (0, 102)  // 接近 180°
  
期望：
  - 吸附到 180°
  - 显示 "← 180°"
```

---

### 集成测试

#### Test 6: Inference + Angle Snap
```
场景：
  - 已有一条 45° 的线
  - 用户从端点拉新线
  - 鼠标接近 90°
  
期望：
  - Parallel Inference 不触发
  - Angle Snap 触发 90°
  - 新线垂直于旧线
```

#### Test 7: Typed Length + Angle Snap
```
输入：
  - 用户输入 "10'"
  - 鼠标方向接近 30°
  
期望：
  - 长度 = 10'
  - 角度吸附到 30°
  - 终点精确计算
```

---

### 22.5° 高级角度测试

#### Test 8: 默认不吸附 22.5°
```
输入：
  - 当前角度集 = architectural
  - 实际角度 22.5°
  
期望：
  - 不吸附（因为不在默认集合）
  - 保持自由角度
```

#### Test 9: Advanced 模式吸附 22.5°
```
输入：
  - 当前角度集 = advanced
  - 实际角度 23°（容差内）
  
期望：
  - 吸附到 22.5°
  - 显示 "22.5°"
```

---

## 📊 实现计划

### 阶段划分

#### Phase 1: 核心几何逻辑（1天）
- [ ] `snapAngle()` 函数
- [ ] `applyAngleSnap()` 函数
- [ ] 单元测试（10个用例）

#### Phase 2: 角度集系统（0.5天）
- [ ] `ANGLE_SETS` 配置
- [ ] 角度集切换逻辑
- [ ] 用户设置持久化

#### Phase 3: UI 反馈（1天）
- [ ] 角度文字提示组件
- [ ] 状态栏集成
- [ ] 视觉反馈样式

#### Phase 4: 集成现有系统（1天）
- [ ] 与 Inference Engine 集成
- [ ] 与 Typed Length 集成
- [ ] 与 Shift 正交模式集成
- [ ] 优先级调度逻辑

#### Phase 5: 测试和优化（0.5天）
- [ ] 边界测试
- [ ] 性能测试
- [ ] 用户体验微调

**总计：** 4天

---

## 🎯 验收清单

### 功能验收

- [ ] **默认角度吸附工作正常**
  - 接近 0°/30°/45°/60°/90° 时自动吸附
  - 容差 ±3° 准确
  - 不误吸其他角度

- [ ] **Shift 强制正交工作正常**
  - 按住 Shift 只画水平/垂直
  - 松开 Shift 恢复智能吸附
  - 与 AutoCAD/SketchUp 手感一致

- [ ] **角度集切换正常**
  - A 键可循环切换
  - 或 UI 设置可选择
  - 22.5° 仅在 Advanced 模式出现

- [ ] **UI 反馈清晰**
  - 用户能明确看到当前角度
  - 吸附时有视觉反馈
  - 不遮挡画布

---

### 性能验收

- [ ] **吸附计算 < 1ms**
  - 即使 1000 条线段
  - 不卡顿画图流程

- [ ] **无内存泄漏**
  - 长时间使用不降速

---

### 集成验收

- [ ] **与 Inference Engine 协同正常**
  - 优先级正确
  - 不互相干扰

- [ ] **与 Typed Length 协同正常**
  - 输入长度 + 角度吸附都生效

- [ ] **与 Grid 独立工作**
  - Grid 不影响角度判断

---

## 🚨 关键注意事项

### 1. 角度优先级是铁律

```
一定按这个顺序：
Typed Length > Explicit Lock > Inference > Angle Snap > Shift > Free

写错了会让用户困惑
```

### 2. Grid ≠ 角度约束

```
Grid 只是视觉参考线
永远不要让 Grid 决定角度
这是和其他工具最大的区别
```

### 3. 22.5° 不默认

```
CPO 明确要求：
"22.5° 是能力，不是默认权力"

默认启用会增加误吸附
只在 Advanced 模式提供
```

### 4. UI 反馈必须有

```
角度被锁了，一定要告诉用户
否则用户会以为是 bug

最低要求：
  - 角度文字提示
  或
  - 状态栏显示
```

---

## 📚 参考资料

### 业界标准

**AutoCAD:**
- Ortho 模式（F8）
- Polar Tracking
- 默认不开 22.5°

**SketchUp:**
- Shift 强制正交
- 推断引擎 + 角度吸附并行
- 视觉反馈清晰

**Bluebeam:**
- 角度吸附容差 3°
- 可自定义角度集

---

### 数学基础

**周期性处理：**
```
角度是周期性的：
  0° = 360°
  90° = 450°
  
需要处理：
  abs(θ1 - θ2)
  abs(θ1 - θ2 + 2π)
  abs(θ1 - θ2 - 2π)
  
取最小值
```

---

## 💬 CPO 原话（重要）

### 关于角度锁定的必要性

> "你这个吐槽我完全共情，而且你这张图本身就是'为什么必须做角度锁定'的铁证。现在这种轻微歪线，在专业画图里是零容忍的。"

### 关于默认体验

> "必须支持「角度锁定 / 角度吸附」，而且要做到：默认就好用，不用点菜单。这是从 magicplan 跨到 AutoCAD / SketchUp 的关键一跃。"

### 关于 22.5°

> "不要默认加 22.5°。可以支持，但必须是「可选 / 高级」而不是默认。这是个专业工具常见分水岭，选错了会直接拉低画图手感。"

### 给 CTO 的话

> "我不希望任何线在没有明确意图的情况下出现 89° 或 91°。默认必须吸附到 30/45/60/90，Shift 强制正交。"

---

## ✅ 开始信号

CTO 可以直接按这个方案开始编码。

**如有疑问：**
- 优先级问题 → 参考第二节
- 实现细节 → 参考第三节
- 测试用例 → 参考第六节

**预计 4 天完成，第 5 天可以给 CPO 演示。**

---

**文档维护者：** CDO  
**最后更新：** 2026-02-03  
**版本：** v1.0  
**状态：** ✅ Ready for Implementation
