# PlanSnap Snap强吸附系统设计规范 v1.0

> **会议时间：** 2026-02-04 07:20  
> **文档类型：** CPO定型文档（设计宪法）  
> **优先级：** 🔴 P0 - 核心手感  
> **状态：** 已定型，待执行

---

## 📋 背景（Why）

### 问题描述

CEO在测试中发现：
1. **闭合失败：** 鼠标靠近绿色引导线时，还能"飘动"，导致闭合不了
2. **Grid交点弱：** Grid交点应该有更强的磁力，但现在不明显
3. **手感不专业：** 不像SketchUp/AutoCAD那样"被拽住"的感觉

### 核心问题本质

当前Snap是"弱吸附 + 允许逃逸"：
- 鼠标看起来在引导线上
- 实际坐标已经偏离
- 最终导致线段不共点，闭合失败
- Contractor完全不知道哪里画错了

👉 **这是CAD/BIM工具的"新手地狱"**

### CPO裁决

**Snap不是辅助，而是接管。**  
**一旦系统知道你想对齐，它就不该再让你犯错。**

---

## 🎯 设计原则（CPO定型，不可随意更改）

### 核心原则

1. **吸附是"状态锁定"，不是"辅助提示"**
2. **引导线与Grid交点进入即锁，不允许漂移**
3. **Grid交点 > 引导线 > Grid线**
4. **闭合点拥有系统级优先权（Closure Bias）**

### 目标

让contractor在**0思考状态**下，画出可闭合、可标注、政府敢收的几何。

---

## 📐 Part A：Snap优先级金字塔

### 优先级定义（从强到弱）

```
┌───────────────────────────┐
│  P0  已有端点 / 闭合点     │  ← 必须锁死
├───────────────────────────┤
│  P1  引导线（延长 / 对齐） │  ← 硬吸附
├───────────────────────────┤
│  P2  Grid 交点             │  ← 超强吸附
├───────────────────────────┤
│  P3  Grid 线               │
├───────────────────────────┤
│  P4  自由空间              │
└───────────────────────────┘
```

### 重要原则（必须遵守）

✅ **高优先级一旦命中，低优先级全部失效**  
✅ **同一时间只允许一个Snap State**  
✅ **Snap ≠ 提示，Snap = 坐标接管权**

---

## 🔄 Part B：Snap状态机设计

### ❌ 明确禁止的做法

- ❌ 多个磁力叠加
- ❌ 距离加权平均
- ❌ "吸一下但还能跑"

### ✅ 正确做法：Snap State Machine

```typescript
// ============================================
// Snap状态枚举
// ============================================
enum SnapState {
  ENDPOINT = 'ENDPOINT',       // P0: 已有端点/闭合点
  GUIDE_LINE = 'GUIDE_LINE',   // P1: 引导线
  GRID_POINT = 'GRID_POINT',   // P2: Grid交点
  GRID_LINE = 'GRID_LINE',     // P3: Grid线
  FREE = 'FREE'                // P4: 自由空间
}

// ============================================
// Snap配置（相对强弱不可颠倒）
// ============================================
const SNAP_CONFIG = {
  // 半径配置（像素）
  ENDPOINT_RADIUS: 12,      // ⭐⭐⭐⭐⭐ 最大
  CLOSURE_RADIUS: 15,       // ⭐⭐⭐⭐⭐ 闭合优先
  GRID_POINT_RADIUS: 10,    // ⭐⭐⭐⭐☆ 比Guide强
  GUIDE_LINE_RADIUS: 8,     // ⭐⭐⭐☆ 锁方向
  GRID_LINE_RADIUS: 6,      // ⭐⭐☆ 辅助
  
  // 视觉反馈
  SNAP_HIGHLIGHT_DURATION: 100, // ms
};

// ============================================
// Snap结果接口
// ============================================
interface SnapResult {
  state: SnapState;
  point: Point;              // 最终锁定坐标
  locked: boolean;           // 是否完全锁定
  lockedAxis?: 'x' | 'y';   // 锁定的轴（仅Guide Line）
  target?: any;              // 吸附目标对象
  visualFeedback: {
    highlight: boolean;
    color?: string;
    icon?: string;
  };
}

// ============================================
// 核心：Snap状态解析器
// ============================================
function resolveSnap(
  cursor: Point,
  context: {
    existingPoints: Point[];
    guideLines: Line[];
    gridPoints: Point[];
    gridLines: Line[];
    startPoint?: Point;      // 用于闭合检测
    isDrawing: boolean;
  }
): SnapResult {
  
  // ========================================
  // P0: 检查闭合点（最高优先级）
  // ========================================
  if (context.isDrawing && context.startPoint) {
    const distToStart = distance(cursor, context.startPoint);
    if (distToStart <= SNAP_CONFIG.CLOSURE_RADIUS) {
      return {
        state: SnapState.ENDPOINT,
        point: context.startPoint,
        locked: true,
        target: context.startPoint,
        visualFeedback: {
          highlight: true,
          color: '#00FF00',
          icon: 'closure'
        }
      };
    }
  }
  
  // ========================================
  // P0: 检查已有端点
  // ========================================
  for (const endpoint of context.existingPoints) {
    const dist = distance(cursor, endpoint);
    if (dist <= SNAP_CONFIG.ENDPOINT_RADIUS) {
      return {
        state: SnapState.ENDPOINT,
        point: endpoint,
        locked: true,
        target: endpoint,
        visualFeedback: {
          highlight: true,
          color: '#FFFFFF'
        }
      };
    }
  }
  
  // ========================================
  // P2: 检查Grid交点（比引导线优先！）
  // ========================================
  for (const gridPoint of context.gridPoints) {
    const dist = distance(cursor, gridPoint);
    if (dist <= SNAP_CONFIG.GRID_POINT_RADIUS) {
      return {
        state: SnapState.GRID_POINT,
        point: gridPoint,
        locked: true,
        target: gridPoint,
        visualFeedback: {
          highlight: true,
          color: '#888888',
          icon: 'crosshair'
        }
      };
    }
  }
  
  // ========================================
  // P1: 检查引导线（硬吸附）
  // ========================================
  for (const guideLine of context.guideLines) {
    const projection = projectPointToLine(cursor, guideLine);
    const dist = distance(cursor, projection);
    
    if (dist <= SNAP_CONFIG.GUIDE_LINE_RADIUS) {
      // 确定锁定的轴
      const lockedAxis = guideLine.isVertical ? 'x' : 'y';
      
      return {
        state: SnapState.GUIDE_LINE,
        point: projection,
        locked: true,
        lockedAxis,
        target: guideLine,
        visualFeedback: {
          highlight: true,
          color: '#00FF00'
        }
      };
    }
  }
  
  // ========================================
  // P3: 检查Grid线
  // ========================================
  for (const gridLine of context.gridLines) {
    const projection = projectPointToLine(cursor, gridLine);
    const dist = distance(cursor, projection);
    
    if (dist <= SNAP_CONFIG.GRID_LINE_RADIUS) {
      const lockedAxis = gridLine.isVertical ? 'x' : 'y';
      
      return {
        state: SnapState.GRID_LINE,
        point: projection,
        locked: false,  // Grid线是辅助，不完全锁定
        lockedAxis,
        target: gridLine,
        visualFeedback: {
          highlight: false
        }
      };
    }
  }
  
  // ========================================
  // P4: 自由空间
  // ========================================
  return {
    state: SnapState.FREE,
    point: cursor,
    locked: false,
    visualFeedback: {
      highlight: false
    }
  };
}

// ============================================
// 辅助函数
// ============================================
function distance(p1: Point, p2: Point): number {
  const dx = p1.x - p2.x;
  const dy = p1.y - p2.y;
  return Math.sqrt(dx * dx + dy * dy);
}

function projectPointToLine(point: Point, line: Line): Point {
  // 投影点计算
  if (line.isVertical) {
    return { x: line.x, y: point.y };
  } else {
    return { x: point.x, y: line.y };
  }
}
```

---

## 💪 Part C：强吸附行为定义

### 1️⃣ 引导线（Guide Line）= 硬吸附

**触发条件：**
```
distance(cursor, guideLine) ≤ guideSnapThreshold
```

**行为规则（定型）：**
- ✅ cursor在法向方向**直接锁死**
- ✅ 只允许沿引导线方向移动
- ❌ 不允许"斜着飘过去"

**体感目标：**
> "鼠标被拽住了"，而不是"有点吸，但还能飘"

---

### 2️⃣ Grid交点（Grid Point）= 超强吸附

**规则（定型）：**
- ✅ Grid交点吸附半径 > 引导线
- ✅ 一旦进入：cursor直接跳到交点
- ❌ 不允许任何微调
- ✅ Grid交点优先级**高于**Grid线

**体感目标：**
> "这里是绝对安全的落点"

**UI表现：**
- 小十字或点
- 出现即代表锁定成功

---

### 3️⃣ 闭合优先原则（Closure Bias）🌟 PlanSnap独有

**定义：**  
当用户"明显意图闭合"，系统**必须**帮他完成闭合。

**触发条件：**
```
distance(currentPoint, startPoint) ≤ closureThreshold
```

**行为：**
- ✅ 强制snap到起点
- ✅ 即使鼠标未精确对准
- ✅ 视觉反馈：起点闪一下 / 高亮1帧
- ✅ 可选轻微"click"感

**CPO裁决：**
> 闭合失败 = 产品失败  
> 不允许交给用户手稳不稳来决定

---

## 🎨 Part D：UI反馈最低要求

### 设计原则

📌 不需要动画  
📌 不需要音效  
📌 只要"确定感"

### 具体要求

| Snap类型 | UI反馈 | 说明 |
|---------|--------|------|
| **引导线** | 绿色线 | 进入硬吸附区：加亮/加粗1帧 |
| **Grid交点** | 小十字或点 | 出现即代表锁定成功 |
| **闭合点** | 起点闪烁 | 高亮1帧，明确提示已闭合 |
| **端点** | 白色高亮 | 简单明确 |

---

## 📊 Snap区域半径配置表

⚠️ **数值不是绝对，相对强弱不可颠倒**

| Snap类型 | 相对半径 | 推荐值(px) | 备注 |
|---------|---------|-----------|------|
| **Endpoint / Closure** | ⭐⭐⭐⭐⭐ | 12-15 | 最大 |
| **Grid Point** | ⭐⭐⭐⭐☆ | 10 | 比Guide强 |
| **Guide Line** | ⭐⭐⭐☆ | 8 | 锁方向 |
| **Grid Line** | ⭐⭐☆ | 6 | 辅助 |
| **Free Space** | — | — | 无 |

---

## ✅ 验收标准（Definition of Done）

### 功能验收

- [ ] **P0端点吸附：** 鼠标靠近端点，直接跳过去，不能飘
- [ ] **P1引导线硬吸附：** 鼠标进入引导线8px内，法向完全锁死
- [ ] **P2 Grid交点最强：** Grid交点半径 > 引导线，一旦进入直接跳
- [ ] **闭合优先：** 距离起点15px内，强制闭合，起点闪烁
- [ ] **状态互斥：** 同一时间只有一个Snap State生效

### 手感验收（关键！）

- [ ] **引导线体感：** "鼠标被拽住"，不是"有点吸"
- [ ] **Grid交点体感：** "绝对安全的落点"
- [ ] **闭合体感：** "系统帮我完成"，不是"考验我手稳"
- [ ] **无思考：** Contractor用0秒理解当前吸附状态

### UI验收

- [ ] 引导线吸附时：绿线加亮1帧
- [ ] Grid交点：小十字出现
- [ ] 闭合点：起点闪烁高亮
- [ ] 端点：白色高亮

### 代码验收

- [ ] 使用Snap State Machine，不是距离加权
- [ ] 优先级严格按P0→P1→P2→P3→P4
- [ ] 配置文件清晰可调
- [ ] 性能：60fps无卡顿

---

## 📅 执行计划

### Day 1（4-6小时）- 状态机核心

**任务：**
1. 实现SnapState枚举和resolveSnap函数
2. 实现优先级逻辑（P0→P4）
3. 基础单元测试

**产出：**
- `SnapStateMachine.ts`
- 单元测试通过

---

### Day 2（4-6小时）- 硬吸附实现

**任务：**
1. 实现引导线硬吸附（法向锁死）
2. 实现Grid交点超强吸附
3. 实现闭合优先逻辑
4. 配置文件

**产出：**
- 三种核心吸附都能工作
- `snapConfig.ts`

---

### Day 3（2-4小时）- UI反馈

**任务：**
1. 引导线加亮效果
2. Grid交点十字显示
3. 闭合点闪烁
4. 整体手感调优

**产出：**
- 视觉反馈完整
- 手感达到SketchUp标准

---

### Day 4（2小时）- 验收测试

**测试用例：**
1. 画一个矩形，测试Grid交点吸附
2. 用引导线画平行线，测试硬锁定
3. 画不规则多边形，测试闭合优先
4. 压力测试：快速移动鼠标

**产出：**
- 所有DoD通过
- 体检报告

---

## 🚨 为什么这件事"必须现在定型"

### 原因

1. **肌肉记忆级别体验**
   - 后面改 = 用户全体重新学习

2. **Contractor评价只有一句话**
   - "这个画线准不准，会不会老是闭合不了"
   - 不是"功能多不多"

3. **专业工具的分水岭**
   - Snap手感 = CAD/BIM工具的灵魂
   - 这是SketchUp vs 业余软件的区别

---

## 📌 CPO最终裁决（一句话）

> **PlanSnap的Snap不是辅助，而是接管。**  
> **一旦系统知道你想对齐，它就不该再让你犯错。**

---

## 📎 附录：示意图

```
场景1：引导线硬吸附
====================

鼠标移动路径：
  ╔════════════════╗
  ║   ×  →  ×  →  × ║  ← 试图偏离
  ║                ║
  ║ ━━━━━━━━━━━━━━ ║  ← 绿色引导线
  ║                ║
  ║   ✓  →  ✓  →  ✓ ║  ← 实际轨迹（锁死在线上）
  ╚════════════════╝

结果：鼠标"被拽住"，无法脱离


场景2：Grid交点超强吸附
======================

  Grid交点吸附区（半径10px）
         ┌─────┐
         │  ╳  │  ← Grid交点
         └─────┘
            ↑
      鼠标进入即跳
      
  引导线吸附区（半径8px）
  ─────────────────
       ↑
  Grid交点优先，引导线失效


场景3：闭合优先
==============

  起点          当前点
    ●─────────→ ×
    ↑           ↓
    │           │
    │           ↓
    └──────←────● ← 距离15px内
    
  结果：强制吸到起点
        起点闪烁
        完成闭合
```

---

**文档版本：** v1.0  
**定型人：** CPO  
**生效日期：** 2026-02-04  
**下一步：** CTO执行，2-4天完成

---

新窗口CDO，这是PlanSnap的"手感宪法"！🚀
