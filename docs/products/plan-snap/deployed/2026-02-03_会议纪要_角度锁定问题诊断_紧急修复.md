# 会议纪要 - 角度锁定功能问题诊断与修复

> **会议时间：** 2026-02-03  
> **会议类型：** 紧急技术问题诊断  
> **参与人员：** CPO、CDO、CTO  
> **问题级别：** 🔴 P0 - Critical  
> **状态：** ✅ 根因已定位，修复方案已确定

---

## 📋 会议背景

### 问题描述

**CPO反馈：**
> "角度并没有锁定，看看是CDO做的执行文档有问题，还是CTO执行过程出问题？"

**现象：**
- 用户画"竖线"时，线条仍然出现89°或91°的偏移
- Shift键按下时，线条不是纯正交
- 角度锁定功能"看起来没生效"

---

## 🔍 问题定位

### 结论（双重问题）

经过代码审查和实际运行分析，问题来源于：

#### 1. CDO文档存在关键矛盾（30%）
- 优先级顺序前后不一致
- Shift实现代码有坑
- Grid处理顺序误导性描述

#### 2. CTO实现架构错位（70%）
- 角度锁定结果被后续逻辑覆盖
- `inferDraw()` 裁决权设计错误
- 多处修改 `end point` 导致最终结果不可预测

**关键发现：**
> "角度其实'算对了'，但在同一个 `inferDraw()` 里被后续的 inference / grid 逻辑'又改掉了'。"

---

## 🐛 CDO文档的三个关键问题

### 问题 1: 优先级顺序前后矛盾 ⚠️

**矛盾描述：**

文档一处写：
```
Shift 正交 > 所有其他角度吸附
```

但同一文档后面的"铁律优先级"写：
```
Smart Angle Snap → Shift Ortho → Free
```

**后果：**
- CTO按"铁律"实现，Shift不一定覆盖Smart Snap
- 用户按Shift时仍可能被吸到30°/45°/60°
- 体验飘忽不定

**正确顺序应该是：**
```
Typed Length → Explicit Lock → Shift Ortho → Inference → Smart Angle Snap → Free
```

---

### 问题 2: Shift分支代码有坑 🚨

**文档中的代码：**
```typescript
// Shift 强制正交
if (options.shiftPressed) {
  const angles = [0, Math.PI/2, Math.PI, 3*Math.PI/2]
  const { snappedAngle } = snapAngle(angle, 90) // ❌ 大容差
  finalAngle = snappedAngle ?? angle
}
```

**问题：**
- `snapAngle()` 使用全套 `SNAP_ANGLES_RAD`（包含30°/45°/60°）
- 容差90°几乎任何角度都会被吸附
- 结果可能吸到非正交角度

**正确做法：**
```typescript
// Shift 只在正交角中选择
if (options.shiftPressed) {
  const ortho = [0, Math.PI/2, Math.PI, 3*Math.PI/2]
  let best = ortho[0]
  let min = Infinity
  for (const a of ortho) {
    const d = angleDelta(angle, a)
    if (d < min) { min = d; best = a }
  }
  finalAngle = best
}
```

---

### 问题 3: Grid处理顺序误导 ⚠️

**文档描述：**
```
"先角度，再 Grid（可选）"
```

**误导性：**
- 如果CTO理解为"角度锁定后再做grid snap"
- Grid会把角度锁定后的端点扯到网格上
- 角度就"肉眼不直"了

**正确理解：**
```
角度锁定期间，Grid只能影响"长度/坐标"，不能破坏角度约束
或更直接：角度锁定时，禁用Grid snap
```

---

## 🏗️ CTO实现的架构问题（核心问题）

### 问题本质

**当前架构：**
```
applyAngleSnap() → 建议（锁角）
inferDraw() → 最终裁决者（可能覆盖）
```

**正确架构：**
```
Angle/Ortho/Lock → 最终裁决者
Inference/Grid → 只能在不破坏约束时参与
```

---

### 致命代码点（实际代码分析）

#### ❌ 问题 1: 几何吸附在锁角之后执行

**当前代码逻辑：**
```typescript
const angleResult = applyAngleSnap(...)  // ✅ 锁角成功
const cx = angleResult.point.x
const cy = angleResult.point.y

const inf = this.infer(cx, cy, ...)  // ❌ 再次推断
if (inf.type === 'endpoint' || 'midpoint' || 'intersection') {
  return {
    ...inf,
    point: projectedPoint,  // ❌ 覆盖锁角结果
  }
}
```

**问题：**
- 锁角点被投影到任意几何点上
- 角度又歪了

---

#### ❌ 问题 2: Grid snap在锁角后仍生效

**当前代码逻辑：**
```typescript
if (angleResult.isSnapped) {
  // 沿锁定方向投影到 grid
  return {
    type: 'angleSnap',
    point: projectedToGridPoint,  // ❌ Grid改变了角度
  }
}
```

**问题：**
- Grid点本身不在角度射线上
- 投影后角度偏移

---

#### ❌ 问题 3: 同一帧多次修改end point

**当前执行顺序：**
```
1. applyAngleSnap()    → 设置 end point
2. infer(...)          → 再次设置 end point
3. Grid snap           → 又一次设置 end point
4. return 最终 point
```

**SketchUp/AutoCAD 明确禁止的模式：**
> "同一帧里，多次修改 end point，且来源不同"

**结果：**
- 最终裁决权不明确
- 视觉上"看起来没锁定"

---

## ✅ 解决方案

### 方案一：最小改动修复（推荐立即执行）

#### 修正 1: 角度锁定后，禁止几何吸附改点

**在 `inferDraw()` 添加判断：**
```typescript
if (angleResult.isSnapped) {
  // ❗角度已经锁定
  // ❌ 不再执行 endpoint / midpoint / intersection 投影
  // ❌ 不再重新 infer 几何点
  
  return {
    type: 'angleSnap',
    point: angleResult.point,  // 直接返回锁角结果
    angleDeg: angleResult.angleDeg,
    isSnapped: true,
    mode: angleResult.mode
  }
}
```

---

#### 修正 2: Grid snap只在free angle时执行

**修改Grid条件判断：**
```typescript
// ❌ 错误
if (angleResult.isSnapped) {
  // 投影到 grid
}

// ✅ 正确
if (!angleResult.isSnapped && gridEnabled) {
  // 才允许 grid snap
}
```

---

#### 修正 3: 建立单一裁决点

**硬规则：**
```
在一次 pointer move 中，最终 end point 只能被设置一次。
Angle/Ortho/Lock 命中后，infer 和 grid 只能"读"，不能"写"。
```

**伪代码：**
```typescript
function inferDraw(start, mouse, draft, settings) {
  // 1. 优先执行角度锁定（最高优先级）
  const angleResult = applyAngleSnap(start, mouse, draft, settings)
  
  // 2. 如果角度已锁定，直接返回，不再处理
  if (angleResult.isSnapped) {
    return {
      type: angleResult.mode,  // 'shift' | 'explicit' | 'smart'
      point: angleResult.point,
      angleDeg: angleResult.angleDeg,
      isSnapped: true
    }
  }
  
  // 3. 角度未锁定，才执行几何推断
  const inf = this.infer(mouse.x, mouse.y, ...)
  
  // 4. 返回推断结果（可能包含grid snap）
  return inf
}
```

---

### 方案二：完整重构版（长期方案）

**提供完整的 `computeFinalEnd()` 函数：**

详见附件：`2026-02-03_代码_完整computeFinalEnd实现.ts`

**核心改进：**
1. 统一终点计算入口
2. 明确优先级顺序
3. 类型安全（TypeScript严格模式）
4. 完整的Debug信息输出

---

## 📊 修复优先级

### 立即修复（今天）- 最小改动版

**工作量：** 1-2小时

**修改点：**
- [ ] `inferDraw()` 添加 `isSnapped` 判断
- [ ] Grid条件改为 `!isSnapped && gridEnabled`
- [ ] 添加Debug overlay显示锁定状态

**验收标准：**
```
1. 画竖线：自动吸附到90°，不偏移
2. 按Shift：只能画0°/90°，不会吸到30°/45°
3. Debug显示：snappedDeg有值时，线条绝对直
```

---

### 后续优化（本周内）- 完整重构版

**工作量：** 0.5天

**修改点：**
- [ ] 迁移到 `computeFinalEnd()` 统一函数
- [ ] 重构 `POINTER_MOVE` reducer逻辑
- [ ] 添加完整的单元测试

**收益：**
- 代码更清晰，易维护
- 类型安全，减少bug
- 性能优化（减少重复计算）

---

## 🔧 CDO文档修正

### 需要修正的文档

**文档名称：**
- `2026-02-03_技术方案_角度锁定系统_CTO执行版.md`
- `2026-02-03_角度锁定系统_快速执行清单.md`

### 修正内容

#### 1. 统一优先级顺序

**全文统一为：**
```
Typed Length → Explicit Lock → Shift Ortho → Inference → Smart Angle Snap → Free
```

**关键说明：**
```
Shift必须比Smart Snap更高（一按Shift就必须0°/90°）
```

---

#### 2. 修正Shift实现代码

**删除：**
```typescript
const { snappedAngle } = snapAngle(angle, 90)  // ❌ 会吸到非正交角
```

**替换为：**
```typescript
function snapToOrtho(theta: number): number {
  const ortho = [0, Math.PI/2, Math.PI, 3*Math.PI/2]
  let best = ortho[0]
  let min = Infinity
  for (const a of ortho) {
    const d = angleDelta(theta, a)
    if (d < min) { min = d; best = a }
  }
  return best
}
```

---

#### 3. 明确Grid处理规则

**添加明确禁止项：**
```
⚠️ 当命中 Shift / Angle Lock / Inference / Smart Snap 时：
   禁止再做 grid snap（否则角度会被网格扯歪）
```

**代码示例：**
```typescript
// ✅ 正确
if (!angleResult.isSnapped && gridEnabled) {
  // 才允许 grid snap
}
```

---

## 🧪 验收清单

### 功能验收

- [ ] **Shift强制正交工作正常**
  - 按住Shift只能画0°/90°/180°/270°
  - 不会吸到30°/45°/60°
  - Debug显示 `source: shift`

- [ ] **Smart Snap工作正常**
  - 不按Shift时，能吸到30°/45°/60°/90°
  - 容差±3°准确
  - Debug显示 `source: smart`

- [ ] **锁角后不被覆盖**
  - `isSnapped === true` 时，Grid不生效
  - 几何推断不再修改end point
  - Debug显示最终角度与锁定角度一致

---

### Debug验收

**必须添加Debug overlay：**
```
显示内容：
  rawDeg: 87.2°        # 原始角度
  snappedDeg: 90°      # 锁定角度
  source: smart        # 锁定来源
  
判断标准：
  - snappedDeg有值但线歪 → 后续被覆盖（修正1未生效）
  - Shift时snappedDeg不是0/90/180/270 → Shift实现错误
  - snappedDeg = null → 算法未触发
```

---

## 💬 关键人物观点

### CPO的明确要求

> "我不希望任何线在没有明确意图的情况下出现 89° 或 91°。默认必须吸附到 30/45/60/90，Shift 强制正交。"

### 给CTO的话（可原文转述）

> "现在角度锁定函数本身是对的，但在 `inferDraw()` 里，锁角结果被后续的 inference 和 grid 再次覆盖了。我们需要让 Angle/Ortho 成为最终裁决，当 `isSnapped === true` 时，禁止任何几何或 grid 再改 end point。"

---

## 📋 行动项

### CTO立即执行（今天完成）

**优先级：** 🔴 P0

**任务：**
1. [ ] 在 `inferDraw()` 添加 `isSnapped` 判断（30分钟）
2. [ ] 修改Grid条件为 `!isSnapped && gridEnabled`（15分钟）
3. [ ] 添加Debug overlay显示锁定状态（30分钟）
4. [ ] 测试三个验收场景（30分钟）

**总计：** 2小时

**交付标准：**
- 画竖线自动吸附90°
- Shift只能画正交
- Debug清晰显示锁定状态

---

### CDO文档修正（今天完成）

**优先级：** 🟡 P1

**任务：**
1. [ ] 修正两份文档的优先级顺序（15分钟）
2. [ ] 替换Shift实现代码（10分钟）
3. [ ] 添加Grid禁止规则（10分钟）
4. [ ] 发布修正版文档（5分钟）

**总计：** 40分钟

**交付标准：**
- 文档内部无矛盾
- 代码示例可直接使用
- 明确禁止项清晰

---

### CTO后续优化（本周内）

**优先级：** 🟢 P2

**任务：**
1. [ ] 迁移到 `computeFinalEnd()` 统一函数（2小时）
2. [ ] 重构 `POINTER_MOVE` reducer（1小时）
3. [ ] 添加单元测试（1小时）

**总计：** 4小时

**交付标准：**
- 代码结构清晰
- 类型安全
- 测试覆盖率>80%

---

## 📚 附件文档

### 会议相关文档

1. **原始技术方案：**
   - `2026-02-03_技术方案_角度锁定系统_CTO执行版.md`
   - `2026-02-03_角度锁定系统_快速执行清单.md`

2. **修正后文档（待创建）：**
   - `2026-02-03_技术方案_角度锁定系统_CTO执行版_v1.1.md`
   - `2026-02-03_角度锁定系统_快速执行清单_v1.1.md`

3. **完整代码实现（待创建）：**
   - `2026-02-03_代码_完整computeFinalEnd实现.ts`
   - `2026-02-03_代码_最小修复补丁.md`

---

## 🎯 核心教训

### 架构层面

**错误模式：**
```
约束函数 → 建议
业务逻辑 → 最终裁决者（可能覆盖）
```

**正确模式：**
```
约束函数 → 最终裁决者
业务逻辑 → 只能在不违反约束时执行
```

---

### 文档层面

**教训：**
1. 优先级描述必须前后一致
2. 代码示例必须经过验证
3. 禁止项必须明确列出

**改进措施：**
- CDO在发布文档前，找CTO Review代码示例
- 关键算法提供可运行的单元测试
- 重要禁止项单独列出，避免淹没在文字中

---

### 沟通层面

**有效模式：**
1. 实际代码截图 > 口头描述
2. 5分钟定位法 > 长时间猜测
3. Debug overlay > 反复试错

**本次成功点：**
- CPO及时反馈"角度没锁定"
- CDO快速提供Debug方案
- CTO配合提供实际代码
- 3方在2小时内定位根因

---

## ✅ 会议结论

### 问题定性

**双重问题：**
1. CDO文档有3处矛盾/坑（30%责任）
2. CTO实现架构错位（70%责任）

**但更重要的是：**
> "这是系统设计问题，不是个人问题。我们需要建立更好的文档Review和代码Review流程。"

---

### 修复方案

**立即执行（今天）：**
- 最小改动修复（2小时）
- 文档修正（40分钟）

**后续优化（本周）：**
- 完整重构（4小时）
- 单元测试补充

---

### 流程改进

**未来执行：**
1. CDO发布技术方案前，CTO Review代码示例
2. CTO实现关键功能后，CPO验收前先自测Debug overlay
3. 所有涉及"优先级"的功能，必须配单元测试

---

## 📞 后续跟进

### 今天EOD前

**CTO提交：**
- 最小修复版本
- Debug overlay演示

**CDO发布：**
- 修正版文档v1.1

### 本周五前

**CTO提交：**
- 完整重构版本
- 单元测试报告

**CPO验收：**
- 三个核心场景测试通过

---

**会议记录人：** CDO  
**会议时间：** 2026-02-03  
**下次Review：** 2026-02-03 EOD（验收最小修复版）  
**状态：** ✅ 根因已定位，修复中

---

## 🎓 给团队的话

这次问题暴露了我们在"约束系统设计"上的经验不足，但通过快速定位和协作，我们在2小时内找到了根因并制定了修复方案。

**记住三点：**

1. **约束必须是最终裁决者**，不是建议
2. **文档代码示例必须能跑**，不能只是伪代码
3. **Debug信息比猜测更重要**，5分钟定位法永远优于反复试错

继续加油！🚀
