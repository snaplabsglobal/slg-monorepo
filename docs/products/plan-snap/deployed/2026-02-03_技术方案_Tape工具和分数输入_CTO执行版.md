# PlanSnap Tapeå·¥å…·å’Œåˆ†æ•°è¾“å…¥ - æŠ€æœ¯æ–¹æ¡ˆ

> **æ–‡æ¡£ç±»å‹ï¼š** æŠ€æœ¯æ–¹æ¡ˆ - CTOæ‰§è¡Œç‰ˆ  
> **åˆ›å»ºæ—¥æœŸï¼š** 2026-02-03  
> **ä¼˜å…ˆçº§ï¼š** ğŸ”´ P0 - Critical  
> **é¢„è®¡å·¥ä½œé‡ï¼š** 5å¤©  
> **çŠ¶æ€ï¼š** â³ å¾…å¼€å§‹

---

## ğŸ“‹ æ‰§è¡Œæ‘˜è¦

### ç›®æ ‡

**æ˜¾è‘—æå‡ç”»å›¾æ‰‹æ„Ÿï¼Œæ·»åŠ ä¸¤ä¸ªæ ¸å¿ƒåŸºç¡€èƒ½åŠ›ï¼š**
1. **Tape Offset Guides** - SketchUpå¼å¹³è¡Œè¾…åŠ©çº¿å·¥å…·
2. **Fraction Input** - æ”¯æŒè‹±åˆ¶åˆ†æ•°è¾“å…¥ï¼ˆ12 1/8"ï¼‰

**CPOæ˜ç¡®è¦æ±‚ï¼š**
> "è¿™ä¸¤é¡¹æ˜¯'ç”»å›¾æ‰‹æ„Ÿçš„åœ°åŸº'ï¼Œæ¯”ç»§ç»­çº ç»“è§’åº¦é”æ›´èƒ½ç«‹åˆ»æå‡ä½“éªŒã€ä¹Ÿæ›´å®¹æ˜“éªŒæ”¶ã€‚"

---

### Scopeï¼ˆæœ¬æ¬¡åªåšï¼‰

**âœ… åšä»€ä¹ˆï¼š**
```
A. Tape Offset Guides
   - ä»»æ„ç‚¹ç”Ÿæˆå¹³è¡Œè¾…åŠ©çº¿
   - æ•°å€¼è¾“å…¥è·ç¦»
   - æ— é™å»¶ä¼¸è™šçº¿

B. Fraction Input / Space
   - æ”¯æŒ 12 1/8 è¾“å…¥
   - Spaceä¸å†æ˜¯Esc
   - ç»Ÿä¸€è§£æå™¨
```

**âŒ ä¸åšä»€ä¹ˆï¼ˆæ˜ç¡®æ’é™¤ï¼‰ï¼š**
```
ä¸åš"æ²¿çº¿æµ‹è· Tape measure"
ä¸åš"å¤šguideé”å®šé“¾å¼åç§»"
ä¸åš"è§’åº¦é”å®š"ç›¸å…³æ”¹åŠ¨ï¼ˆæœ¬æ¬¡å†»ç»“ï¼‰
```

---

## ğŸ—ï¸ A. Tape Offset Guides

### ä¸€ã€çŠ¶æ€æœºè®¾è®¡

#### å·¥å…·çº§çŠ¶æ€

```typescript
// å…¨å±€å·¥å…·çŠ¶æ€
type Tool = 
  | 'SELECT'
  | 'DRAW_LINE'
  | 'TAPE_GUIDE'  // æ–°å¢
  | 'DIMENSION'
  | ...
```

---

#### Tapeå·¥å…·å†…éƒ¨çŠ¶æ€

```typescript
type TapeState =
  | { phase: 'IDLE' }
  
  | { 
      phase: 'HOVER_SEGMENT'
      segmentId: string
      hoverPoint: Pt  // æŠ•å½±ç‚¹
    }
  
  | { 
      phase: 'ARMED'
      segmentId: string
      anchor: Pt      // é”å®šçš„é”šç‚¹
      u: Vec          // å¹³è¡Œæ–¹å‘ï¼ˆå•ä½å‘é‡ï¼‰
      n: Vec          // æ³•çº¿æ–¹å‘ï¼ˆå•ä½å‘é‡ï¼‰
    }
  
  | { 
      phase: 'DRAGGING'
      segmentId: string
      anchor: Pt
      u: Vec
      n: Vec
      dMm: number           // å½“å‰offsetè·ç¦»ï¼ˆmmï¼‰
      previewGuide: Guide   // é¢„è§ˆçš„guide
    }
  
  | { 
      phase: 'TYPING'
      segmentId: string
      anchor: Pt
      u: Vec
      n: Vec
      typing: string        // è¾“å…¥buffer
      dMm?: number          // è§£æåçš„è·ç¦»ï¼ˆå¯é€‰ï¼‰
      previewGuide?: Guide  // é¢„è§ˆçš„guideï¼ˆå¯é€‰ï¼‰
    }
  
  | { phase: 'COMMITTED' }  // å¯é€‰çš„ç»ˆæ€
```

---

#### çŠ¶æ€è½¬æ¢å›¾

```
IDLE
  â†“ (é¼ æ ‡ç§»åˆ°çº¿æ®µ)
HOVER_SEGMENT
  â†“ (ç‚¹å‡»)
ARMED
  â†“ (æ‹–æ‹½)
DRAGGING
  â†“ (è¾“å…¥æ•°å­—)
TYPING
  â†“ (Enter)
COMMITTED â†’ IDLE/HOVER_SEGMENT

ä»»ä½•çŠ¶æ€ + Esc â†’ å›åˆ° HOVER_SEGMENT/IDLEï¼ˆä¸é€€å‡ºå·¥å…·ï¼‰
```

---

### äºŒã€æ•°æ®ç»“æ„

#### Guideå®ä½“

```typescript
type Guide = {
  id: string
  kind: 'guide'  // å®ä½“ç±»å‹æ ‡è¯†
  
  // æ— é™çº¿å®šä¹‰ï¼ˆç‚¹+æ–¹å‘ï¼‰
  p: Pt          // anchor shifted point P'
  dir: Vec       // parallel direction uï¼ˆå•ä½å‘é‡ï¼‰
  
  // å…ƒæ•°æ®
  createdAt: number
  source: {
    segmentId: string   // å‚ç…§çº¿æ®µ
    anchor: Pt          // åŸå§‹é”šç‚¹
    offsetMm: number    // åç§»è·ç¦»ï¼ˆå¸¦ç¬¦å·ï¼‰
  }
}
```

**å…³é”®ç‚¹ï¼š**
- Guideæ˜¯**æ— é™çº¿**ï¼Œä¸æ˜¯çº¿æ®µ
- å­˜å‚¨åœ¨ç‹¬ç«‹çš„ `guides: Guide[]` layer
- ä¸å‚ä¸é—­åˆæ£€æµ‹
- ä¸è®¡å…¥é¢ç§¯è®¡ç®—
- å¯ä½œä¸ºsnapç›®æ ‡

---

#### Segmentç»“æ„ï¼ˆå‚è€ƒï¼‰

```typescript
// ç°æœ‰çº¿æ®µç»“æ„
type Segment = {
  id: string
  kind: 'wall' | 'guide_line' | ...
  startNodeId: string
  endNodeId: string
  // ...
}
```

---

### ä¸‰ã€æ ¸å¿ƒç®—æ³•

#### 1. onSegmentæŠ•å½±

**è¾“å…¥ï¼š**
```
mouse: Pt
segment: { A: Pt, B: Pt }
```

**è¾“å‡ºï¼š**
```
hoverPoint: Pt
```

**ç®—æ³•ï¼š**
```typescript
function projectPointToSegment(
  mouse: Pt, 
  A: Pt, 
  B: Pt
): { point: Pt; t: number } {
  const AB = sub(B, A)
  const AM = sub(mouse, A)
  
  // å‚æ•°t âˆˆ [0, 1]
  const lenAB2 = dot(AB, AB)
  let t = dot(AM, AB) / lenAB2
  t = clamp(t, 0, 1)  // é™åˆ¶åœ¨çº¿æ®µèŒƒå›´å†…
  
  const point = add(A, mul(AB, t))
  
  return { point, t }
}
```

---

#### 2. è®¡ç®—å¹³è¡Œå’Œæ³•çº¿æ–¹å‘

**è¾“å…¥ï¼š**
```
A: Pt
B: Pt
```

**è¾“å‡ºï¼š**
```
u: Vec  // å¹³è¡Œæ–¹å‘ï¼ˆå•ä½å‘é‡ï¼‰
n: Vec  // æ³•çº¿æ–¹å‘ï¼ˆå•ä½å‘é‡ï¼‰
```

**ç®—æ³•ï¼š**
```typescript
function computeDirections(
  A: Pt, 
  B: Pt
): { u: Vec; n: Vec } {
  // å¹³è¡Œæ–¹å‘
  const AB = sub(B, A)
  const u = normalize(AB)
  
  // æ³•çº¿æ–¹å‘ï¼ˆå‚ç›´äºuï¼‰
  // 2Dä¸­ï¼š(x, y) â†’ (-y, x) æˆ– (y, -x)
  const n = { x: -u.y, y: u.x }  // é€†æ—¶é’ˆ90Â°
  
  return { u, n }
}
```

---

#### 3. è®¡ç®—offsetè·ç¦»å’Œæ–¹å‘

**è¾“å…¥ï¼š**
```
mouse: Pt
anchor: Pt
n: Vec  // æ³•çº¿æ–¹å‘
```

**è¾“å‡ºï¼š**
```
d: number  // å¸¦ç¬¦å·çš„è·ç¦»ï¼ˆmmï¼‰
```

**ç®—æ³•ï¼š**
```typescript
function computeOffset(
  mouse: Pt,
  anchor: Pt,
  n: Vec
): number {
  const delta = sub(mouse, anchor)
  const d = dot(delta, n)
  
  // d > 0: æ­£æ–¹å‘
  // d < 0: è´Ÿæ–¹å‘
  return d
}
```

---

#### 4. ç”ŸæˆGuideä½ç½®

**è¾“å…¥ï¼š**
```
anchor: Pt
n: Vec
dMm: number  // è·ç¦»ï¼ˆmmï¼Œå¸¦ç¬¦å·ï¼‰
u: Vec       // å¹³è¡Œæ–¹å‘
```

**è¾“å‡ºï¼š**
```
guide: { p: Pt, dir: Vec }
```

**ç®—æ³•ï¼š**
```typescript
function computeGuidePosition(
  anchor: Pt,
  n: Vec,
  dMm: number,
  u: Vec
): { p: Pt; dir: Vec } {
  // åç§»ç‚¹
  const p = add(anchor, mul(n, dMm))
  
  // æ–¹å‘ä¿æŒä¸å˜
  const dir = u
  
  return { p, dir }
}
```

---

### å››ã€äº¤äº’æµç¨‹è¯¦è§£

#### Phase 1: IDLE â†’ HOVER_SEGMENT

**è§¦å‘ï¼š** é¼ æ ‡ç§»åˆ°ä»»æ„çº¿æ®µä¸Š

**çŠ¶æ€æ›´æ–°ï¼š**
```typescript
onPointerMove(mouse: Pt) {
  // æŸ¥æ‰¾æœ€è¿‘çº¿æ®µ
  const closest = findClosestSegment(mouse, maxDistance = 10px)
  
  if (closest) {
    const { point } = projectPointToSegment(
      mouse, 
      closest.A, 
      closest.B
    )
    
    setState({
      phase: 'HOVER_SEGMENT',
      segmentId: closest.id,
      hoverPoint: point
    })
  } else {
    setState({ phase: 'IDLE' })
  }
}
```

**UIåé¦ˆï¼š**
```
æ˜¾ç¤º "On Segment" æç¤º
é«˜äº®hoverPoint
```

---

#### Phase 2: HOVER_SEGMENT â†’ ARMED

**è§¦å‘ï¼š** ç‚¹å‡»

**çŠ¶æ€æ›´æ–°ï¼š**
```typescript
onPointerDown(mouse: Pt) {
  if (state.phase === 'HOVER_SEGMENT') {
    const segment = getSegment(state.segmentId)
    const { u, n } = computeDirections(segment.A, segment.B)
    
    setState({
      phase: 'ARMED',
      segmentId: state.segmentId,
      anchor: state.hoverPoint,
      u,
      n
    })
  }
}
```

**UIåé¦ˆï¼š**
```
é”šç‚¹å›ºå®š
æ˜¾ç¤ºé”å®šæ ‡è®°
```

---

#### Phase 3: ARMED â†’ DRAGGING

**è§¦å‘ï¼š** é¼ æ ‡æ‹–æ‹½

**çŠ¶æ€æ›´æ–°ï¼š**
```typescript
onPointerMove(mouse: Pt) {
  if (state.phase === 'ARMED') {
    const dMm = computeOffset(mouse, state.anchor, state.n)
    const { p, dir } = computeGuidePosition(
      state.anchor,
      state.n,
      dMm,
      state.u
    )
    
    const previewGuide: Guide = {
      id: 'preview',
      kind: 'guide',
      p,
      dir,
      createdAt: Date.now(),
      source: {
        segmentId: state.segmentId,
        anchor: state.anchor,
        offsetMm: dMm
      }
    }
    
    setState({
      phase: 'DRAGGING',
      ...state,
      dMm,
      previewGuide
    })
  }
}
```

**UIåé¦ˆï¼š**
```
æ˜¾ç¤ºé¢„è§ˆè™šçº¿ï¼ˆæ— é™å»¶ä¼¸ï¼‰
æ˜¾ç¤ºè·ç¦»æ•°å­—
```

---

#### Phase 4: DRAGGING â†’ TYPING

**è§¦å‘ï¼š** è¾“å…¥æ•°å­—

**çŠ¶æ€æ›´æ–°ï¼š**
```typescript
onKeyDown(key: string) {
  if (state.phase === 'DRAGGING' && isInputChar(key)) {
    setState({
      phase: 'TYPING',
      segmentId: state.segmentId,
      anchor: state.anchor,
      u: state.u,
      n: state.n,
      typing: key,
      dMm: undefined,
      previewGuide: undefined
    })
  }
}
```

**æŒç»­è¾“å…¥ï¼š**
```typescript
onKeyDown(key: string) {
  if (state.phase === 'TYPING') {
    if (isInputChar(key)) {
      // è¿½åŠ åˆ°buffer
      setState({
        ...state,
        typing: state.typing + key
      })
      
      // å°è¯•è§£æ
      try {
        const dMm = parseLengthToMM(state.typing, defaultUnit)
        // ä½¿ç”¨æ‹–æ‹½æ—¶çš„æ–¹å‘ç¬¦å·
        const signedDMm = Math.sign(lastDragD || 1) * Math.abs(dMm)
        
        const { p, dir } = computeGuidePosition(
          state.anchor,
          state.n,
          signedDMm,
          state.u
        )
        
        setState({
          ...state,
          dMm: signedDMm,
          previewGuide: { /* ... */ }
        })
      } catch {
        // è§£æå¤±è´¥ï¼Œä¿æŒtypingçŠ¶æ€
      }
    }
  }
}
```

**UIåé¦ˆï¼š**
```
å…‰æ ‡é™„è¿‘æ˜¾ç¤ºè¾“å…¥å†…å®¹
é¢„è§ˆguideéšè¾“å…¥æ›´æ–°
```

---

#### Phase 5: TYPING â†’ COMMITTED

**è§¦å‘ï¼š** Enter

**çŠ¶æ€æ›´æ–°ï¼š**
```typescript
onKeyDown(key: string) {
  if (state.phase === 'TYPING' && key === 'Enter') {
    if (state.dMm !== undefined && state.previewGuide) {
      // æäº¤guide
      const guide = {
        ...state.previewGuide,
        id: generateId()
      }
      
      addGuide(guide)
      
      setState({ phase: 'IDLE' })
      // æˆ– { phase: 'HOVER_SEGMENT' }ï¼Œå¦‚æœé¼ æ ‡ä»åœ¨segmentä¸Š
    }
  }
}
```

---

#### å–æ¶ˆæ“ä½œï¼ˆä»»ä½•é˜¶æ®µï¼‰

**è§¦å‘ï¼š** Esc

**çŠ¶æ€æ›´æ–°ï¼š**
```typescript
onKeyDown(key: string) {
  if (key === 'Escape') {
    switch (state.phase) {
      case 'ARMED':
      case 'DRAGGING':
      case 'TYPING':
        // å–æ¶ˆå½“å‰guideï¼Œå›åˆ°hoverçŠ¶æ€
        setState({ phase: 'HOVER_SEGMENT', /* ä¿ç•™segmentä¿¡æ¯ */ })
        break
      
      case 'HOVER_SEGMENT':
        setState({ phase: 'IDLE' })
        break
      
      default:
        // IDLEçŠ¶æ€ï¼ŒEscä¸åšä»»ä½•äº‹
        break
    }
  }
}
```

**å…³é”®ï¼š**
- Esc **ä¸é€€å‡º** Tapeå·¥å…·
- åªå–æ¶ˆå½“å‰guideç”Ÿæˆ
- å¯ä»¥è¿ç»­ç”Ÿæˆå¤šä¸ªguide

---

### äº”ã€æ¸²æŸ“å®ç°

#### æ— é™çº¿æ¸²æŸ“

**é—®é¢˜ï¼š** Guideæ˜¯æ— é™çº¿ï¼Œä¸èƒ½ç›´æ¥æ¸²æŸ“

**è§£å†³ï¼š** è®¡ç®—ä¸è§†å£è¾¹ç•Œçš„äº¤ç‚¹

```typescript
function renderGuide(
  guide: Guide,
  viewport: { xMin, xMax, yMin, yMax }
): { A: Pt, B: Pt } | null {
  const { p, dir } = guide
  
  // è®¡ç®—ä¸è§†å£å››æ¡è¾¹çš„äº¤ç‚¹
  const intersections: Pt[] = []
  
  // ä¸ä¸Šè¾¹ç•Œäº¤ç‚¹
  if (dir.y !== 0) {
    const t = (viewport.yMin - p.y) / dir.y
    const x = p.x + t * dir.x
    if (x >= viewport.xMin && x <= viewport.xMax) {
      intersections.push({ x, y: viewport.yMin })
    }
  }
  
  // ä¸ä¸‹è¾¹ç•Œäº¤ç‚¹ï¼ˆç±»ä¼¼ï¼‰
  // ä¸å·¦è¾¹ç•Œäº¤ç‚¹ï¼ˆç±»ä¼¼ï¼‰
  // ä¸å³è¾¹ç•Œäº¤ç‚¹ï¼ˆç±»ä¼¼ï¼‰
  
  if (intersections.length >= 2) {
    return {
      A: intersections[0],
      B: intersections[1]
    }
  }
  
  return null
}
```

---

#### è§†è§‰æ ·å¼

**æ ·å¼å®šä¹‰ï¼š**
```typescript
const GUIDE_STYLE = {
  strokeColor: 'rgba(100, 100, 255, 0.5)',  // æ·¡è“è‰²
  strokeWidth: 0.5,                          // æ¯”æ™®é€šçº¿ç»†
  lineDash: [4, 4],                          // è™šçº¿
  lineCap: 'round'
}
```

**Canvasæ¸²æŸ“ï¼š**
```typescript
function drawGuide(ctx: CanvasRenderingContext2D, guide: Guide) {
  const segment = renderGuide(guide, currentViewport)
  if (!segment) return
  
  ctx.save()
  
  ctx.strokeStyle = GUIDE_STYLE.strokeColor
  ctx.lineWidth = GUIDE_STYLE.strokeWidth
  ctx.setLineDash(GUIDE_STYLE.lineDash)
  ctx.lineCap = GUIDE_STYLE.lineCap
  
  ctx.beginPath()
  ctx.moveTo(segment.A.x, segment.A.y)
  ctx.lineTo(segment.B.x, segment.B.y)
  ctx.stroke()
  
  ctx.restore()
}
```

---

### å…­ã€Snapé›†æˆ

#### Guideä½œä¸ºSnapç›®æ ‡

**æ–°å¢Inferenceç±»å‹ï¼š**
```typescript
type InferenceType = 
  | 'none'
  | 'endpoint'
  | 'midpoint'
  | 'onSegment'
  | 'onGuide'           // æ–°å¢ï¼šè½åœ¨guideä¸Š
  | 'guideIntersection' // æ–°å¢ï¼šguideäº¤ç‚¹
  | ...
```

---

#### onGuideæ¨æ–­

```typescript
function inferOnGuide(
  mouse: Pt,
  guides: Guide[],
  tolerance: number = 10
): Inference | null {
  for (const guide of guides) {
    // è®¡ç®—é¼ æ ‡åˆ°guideçš„è·ç¦»
    const d = distancePointToLine(mouse, guide.p, guide.dir)
    
    if (d < tolerance) {
      // æŠ•å½±åˆ°guideä¸Š
      const point = projectPointToLine(mouse, guide.p, guide.dir)
      
      return {
        type: 'onGuide',
        point,
        guideId: guide.id,
        score: 50  // ä¼˜å…ˆçº§é€‚ä¸­
      }
    }
  }
  
  return null
}
```

---

#### Guideäº¤ç‚¹æ¨æ–­

```typescript
function inferGuideIntersection(
  mouse: Pt,
  guides: Guide[],
  tolerance: number = 10
): Inference | null {
  // éå†æ‰€æœ‰guideå¯¹
  for (let i = 0; i < guides.length; i++) {
    for (let j = i + 1; j < guides.length; j++) {
      const intersection = lineIntersection(
        guides[i].p, guides[i].dir,
        guides[j].p, guides[j].dir
      )
      
      if (intersection && distance(mouse, intersection) < tolerance) {
        return {
          type: 'guideIntersection',
          point: intersection,
          guideIds: [guides[i].id, guides[j].id],
          score: 95  // é«˜ä¼˜å…ˆçº§
        }
      }
    }
  }
  
  return null
}
```

---

### ä¸ƒã€Snapä¼˜å…ˆçº§ï¼ˆTapeæ¨¡å¼ç‰¹æ®Šï¼‰

#### Tapeæ¨¡å¼ä¸­çš„Snapè§„åˆ™

**å½“å‰å·¥å…· = TAPE_GUIDEï¼š**
```typescript
function inferInTapeMode(mouse: Pt): Inference {
  // 1. onSegmentï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
  const onSeg = inferOnSegment(mouse, allSegments)
  if (onSeg) return onSeg
  
  // 2. ä¸ä½¿ç”¨å…¶ä»–snap
  // ç†ç”±ï¼šTapeä¸“æ³¨äºçº¿æ®µå‚ç…§
  
  return { type: 'none' }
}
```

---

#### DRAW_LINEæ¨¡å¼ä¸­çš„Snapè§„åˆ™

**å½“å‰å·¥å…· = DRAW_LINEï¼š**
```typescript
function inferInDrawLineMode(mouse: Pt): Inference {
  // æŒ‰ä¼˜å…ˆçº§æ’åº
  const candidates: Inference[] = [
    inferEndpoint(mouse, nodes),
    inferGuideIntersection(mouse, guides),
    inferMidpoint(mouse, segments),
    inferIntersection(mouse, segments),
    inferOnGuide(mouse, guides),
    inferOnSegment(mouse, segments),
    inferGrid(mouse, gridSettings)
  ].filter(Boolean)
  
  // è¿”å›å¾—åˆ†æœ€é«˜çš„
  return candidates.sort((a, b) => b.score - a.score)[0] || { type: 'none' }
}
```

---

## ğŸ—ï¸ B. Fraction Input & Spaceè¡Œä¸º

### ä¸€ã€è¾“å…¥çŠ¶æ€æœºè®¾è®¡

#### å…¨å±€è¾“å…¥çŠ¶æ€

```typescript
type InputState =
  | { mode: 'IDLE' }
  
  | { 
      mode: 'TYPING'
      buffer: string
      context: 'length' | 'offset' | 'dimension'
    }
  
  | { 
      mode: 'INVALID'
      buffer: string
      context: 'length' | 'offset' | 'dimension'
    }
```

**å…³é”®ç‚¹ï¼š**
- è¾“å…¥çŠ¶æ€æ˜¯**å…¨å±€**çš„ï¼Œä¸å±äºä»»ä½•å•ä¸€å·¥å…·
- æ‰€æœ‰å·¥å…·å…±äº«åŒä¸€ä¸ªè¾“å…¥çŠ¶æ€æœº

---

#### çŠ¶æ€è½¬æ¢å›¾

```
IDLE
  â†“ (è¾“å…¥æ•°å­—/æœ‰æ•ˆå­—ç¬¦)
TYPING
  â†“ (è§£æå¤±è´¥)
INVALID
  â†“ (ç»§ç»­è¾“å…¥/ä¿®æ­£)
TYPING
  â†“ (Enter)
IDLEï¼ˆæäº¤ï¼‰

TYPING/INVALID + Esc â†’ IDLEï¼ˆæ¸…ç©ºï¼Œä¸æäº¤ï¼‰
```

---

### äºŒã€å…³é”®è¡Œä¸ºè§„èŒƒ

#### Spaceè¡Œä¸ºï¼ˆæ ¸å¿ƒï¼‰

**è§„åˆ™ï¼š**
```
å½“ inputState.mode === 'TYPING':
  Space â†’ è¿½åŠ åˆ° bufferï¼ˆåˆ†éš”ç¬¦ï¼‰

å½“ inputState.mode === 'IDLE':
  Space â†’ å¯èƒ½çš„å–æ¶ˆæ“ä½œï¼ˆå¯é€‰ï¼Œå¦‚æœä¿ç•™åŸè¡Œä¸ºï¼‰
```

**å®ç°ï¼š**
```typescript
function onKeyDown(key: string) {
  if (key === 'Space') {
    if (inputState.mode === 'TYPING') {
      // TYPINGçŠ¶æ€ï¼šSpaceæ˜¯è¾“å…¥å­—ç¬¦
      appendToBuffer(' ')
      return true  // é˜»æ­¢é»˜è®¤è¡Œä¸º
    } else {
      // IDLEçŠ¶æ€ï¼šSpaceå¯èƒ½æ˜¯å–æ¶ˆï¼ˆå¯é€‰ï¼‰
      if (ENABLE_SPACE_CANCEL) {
        cancelCurrentOperation()
      }
    }
  }
}
```

---

#### Escapeè¡Œä¸º

**è§„åˆ™ï¼š**
```
å½“ inputState.mode === 'TYPING':
  Esc â†’ æ¸…ç©º buffer â†’ IDLEï¼ˆä¸é€€å‡ºå·¥å…·ï¼‰

å½“ inputState.mode === 'IDLE':
  Esc â†’ å–æ¶ˆå½“å‰æ“ä½œï¼ˆå¦‚å–æ¶ˆç”»çº¿ã€å–æ¶ˆguideï¼‰
```

**å®ç°ï¼š**
```typescript
function onKeyDown(key: string) {
  if (key === 'Escape') {
    if (inputState.mode === 'TYPING') {
      // TYPINGçŠ¶æ€ï¼šæ¸…ç©ºè¾“å…¥
      clearBuffer()
      setInputState({ mode: 'IDLE' })
      return true  // é˜»æ­¢é»˜è®¤è¡Œä¸º
    } else {
      // IDLEçŠ¶æ€ï¼šå–æ¶ˆæ“ä½œ
      cancelCurrentOperation()
    }
  }
}
```

---

#### Enterè¡Œä¸º

**è§„åˆ™ï¼š**
```
å½“ inputState.mode === 'TYPING':
  Enter â†’ parse buffer â†’ commit â†’ IDLE
```

**å®ç°ï¼š**
```typescript
function onKeyDown(key: string) {
  if (key === 'Enter' && inputState.mode === 'TYPING') {
    try {
      const valueMm = parseLengthToMM(
        inputState.buffer,
        defaultUnit
      )
      
      // æäº¤åˆ°å½“å‰å·¥å…·
      currentTool.onTypedValue(valueMm, inputState.context)
      
      // æ¸…ç©ºçŠ¶æ€
      clearBuffer()
      setInputState({ mode: 'IDLE' })
    } catch (error) {
      // è§£æå¤±è´¥
      setInputState({
        mode: 'INVALID',
        buffer: inputState.buffer,
        context: inputState.context
      })
    }
  }
}
```

---

### ä¸‰ã€è§£æå™¨å®ç°

#### parseLengthToMMå‡½æ•°

```typescript
/**
 * ç»Ÿä¸€é•¿åº¦è§£æå™¨
 * 
 * @param input - ç”¨æˆ·è¾“å…¥å­—ç¬¦ä¸²
 * @param defaultUnit - é»˜è®¤å•ä½ï¼ˆ'in' | 'mm'ï¼‰
 * @returns é•¿åº¦ï¼ˆmmï¼‰
 * 
 * æ”¯æŒæ ¼å¼ï¼š
 * - 12 1/8       â†’ 12.125 in
 * - 1/8          â†’ 0.125 in
 * - 12.5         â†’ 12.5 (defaultUnit)
 * - 114"         â†’ 114 in
 * - 9'6          â†’ 114 in
 * - 9' 6"        â†’ 114 in
 * - 9'-6 3/16"   â†’ 114.1875 in
 * - 300mm        â†’ 300 mm
 * - 2.3m         â†’ 2300 mm
 */
export function parseLengthToMM(
  input: string,
  defaultUnit: 'in' | 'mm' = 'in'
): number {
  // æ¸…ç†è¾“å…¥
  const cleaned = input.trim()
  if (!cleaned) throw new Error('Empty input')
  
  // æ£€æµ‹æ˜¾å¼å•ä½
  const hasInch = cleaned.includes('"') || cleaned.includes('in')
  const hasFeet = cleaned.includes("'") || cleaned.includes('ft')
  const hasMM = cleaned.includes('mm')
  const hasM = cleaned.includes('m') && !cleaned.includes('mm')
  
  let valueInDefaultUnit: number
  
  // å¤„ç†è‹±åˆ¶ï¼ˆfeet + inchï¼‰
  if (hasFeet || hasInch) {
    valueInDefaultUnit = parseFeetInch(cleaned)
    defaultUnit = 'in'  // å¼ºåˆ¶å•ä½ä¸ºinch
  }
  // å¤„ç†å…¬åˆ¶
  else if (hasMM) {
    valueInDefaultUnit = parseFloat(cleaned.replace('mm', ''))
    defaultUnit = 'mm'
  }
  else if (hasM) {
    valueInDefaultUnit = parseFloat(cleaned.replace('m', '')) * 1000
    defaultUnit = 'mm'
  }
  // å¤„ç†åˆ†æ•°ï¼ˆæ— æ˜¾å¼å•ä½ï¼‰
  else if (cleaned.includes('/')) {
    valueInDefaultUnit = parseFraction(cleaned)
  }
  // å¤„ç†çº¯æ•°å­—
  else {
    valueInDefaultUnit = parseFloat(cleaned)
  }
  
  if (!isFinite(valueInDefaultUnit)) {
    throw new Error('Invalid number')
  }
  
  // è½¬æ¢ä¸ºmm
  if (defaultUnit === 'in') {
    return valueInDefaultUnit * 25.4
  } else {
    return valueInDefaultUnit
  }
}
```

---

#### parseFeetInchè¾…åŠ©å‡½æ•°

```typescript
function parseFeetInch(input: string): number {
  // æ”¯æŒæ ¼å¼ï¼š
  // 9'6
  // 9' 6"
  // 9'-6"
  // 9'-6 3/16"
  
  let totalInches = 0
  
  // æå–feetéƒ¨åˆ†
  const feetMatch = input.match(/(\d+(?:\.\d+)?)\s*['ft]/i)
  if (feetMatch) {
    totalInches += parseFloat(feetMatch[1]) * 12
  }
  
  // æå–inchæ•´æ•°éƒ¨åˆ†
  const inchMatch = input.match(/(\d+(?:\.\d+)?)\s*[""in]/i)
  if (inchMatch) {
    totalInches += parseFloat(inchMatch[1])
  }
  
  // æå–inchåˆ†æ•°éƒ¨åˆ†
  const fractionMatch = input.match(/(\d+)\s*\/\s*(\d+)/)
  if (fractionMatch) {
    const numerator = parseInt(fractionMatch[1])
    const denominator = parseInt(fractionMatch[2])
    totalInches += numerator / denominator
  }
  
  return totalInches
}
```

---

#### parseFractionè¾…åŠ©å‡½æ•°

```typescript
function parseFraction(input: string): number {
  // æ”¯æŒæ ¼å¼ï¼š
  // 12 1/8  â†’ 12.125
  // 1/8     â†’ 0.125
  
  // åŒ¹é… "æ•´æ•° åˆ†æ•°" æˆ– "åˆ†æ•°"
  const match = input.match(/^(\d+(?:\.\d+)?)?\s*(\d+)\s*\/\s*(\d+)$/)
  
  if (match) {
    const whole = match[1] ? parseFloat(match[1]) : 0
    const numerator = parseInt(match[2])
    const denominator = parseInt(match[3])
    
    return whole + numerator / denominator
  }
  
  throw new Error('Invalid fraction')
}
```

---

### å››ã€UIç»„ä»¶å®ç°

#### Typing Overlayç»„ä»¶

```typescript
interface TypingOverlayProps {
  inputState: InputState
  cursorPos: { x: number; y: number }  // å±å¹•åæ ‡
}

function TypingOverlay({ inputState, cursorPos }: TypingOverlayProps) {
  if (inputState.mode === 'IDLE') return null
  
  const isInvalid = inputState.mode === 'INVALID'
  const text = inputState.buffer || ''
  
  return (
    <div
      className={`typing-overlay ${isInvalid ? 'invalid' : ''}`}
      style={{
        position: 'fixed',
        left: cursorPos.x + 20,
        top: cursorPos.y - 30,
        pointerEvents: 'none'
      }}
    >
      {text}
    </div>
  )
}
```

---

#### CSSæ ·å¼

```css
.typing-overlay {
  background: rgba(0, 0, 0, 0.85);
  color: #0f0;
  padding: 4px 8px;
  border-radius: 3px;
  font-family: 'Courier New', monospace;
  font-size: 14px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.typing-overlay.invalid {
  background: rgba(200, 0, 0, 0.85);
  color: #fff;
}
```

---

### äº”ã€å·¥å…·é›†æˆ

#### Tapeå·¥å…·æ¥æ”¶è¾“å…¥

```typescript
class TapeGuideT tool {
  onTypedValue(valueMm: number, context: 'offset') {
    if (this.state.phase === 'TYPING') {
      // ä½¿ç”¨æ‹–æ‹½æ—¶çš„æ–¹å‘ç¬¦å·
      const sign = Math.sign(this.lastDragOffset || 1)
      const signedValueMm = sign * Math.abs(valueMm)
      
      // ç”Ÿæˆguide
      const { p, dir } = computeGuidePosition(
        this.state.anchor,
        this.state.n,
        signedValueMm,
        this.state.u
      )
      
      // æäº¤
      this.commitGuide({ p, dir, offsetMm: signedValueMm })
      
      // å›åˆ°hoverçŠ¶æ€
      this.setState({ phase: 'HOVER_SEGMENT' })
    }
  }
}
```

---

#### DrawLineå·¥å…·æ¥æ”¶è¾“å…¥

```typescript
class DrawLineTool {
  onTypedValue(valueMm: number, context: 'length') {
    if (this.state.phase === 'DRAWING') {
      // æ²¿å½“å‰æ–¹å‘å®šé•¿
      const dir = normalize(sub(this.state.end, this.state.start))
      const end = add(this.state.start, mul(dir, valueMm))
      
      // æ›´æ–°ç»ˆç‚¹
      this.setState({
        ...this.state,
        end,
        typedLength: valueMm
      })
    }
  }
}
```

---

## ğŸ“Š å®ç°è®¡åˆ’

### Day 1: TapeåŸºç¡€ï¼ˆ6å°æ—¶ï¼‰

**ä»»åŠ¡ï¼š**
- [ ] TapeçŠ¶æ€æœºå®ç°ï¼ˆ2å°æ—¶ï¼‰
- [ ] onSegmentæŠ•å½±ç®—æ³•ï¼ˆ2å°æ—¶ï¼‰
- [ ] HOVER â†’ ARMED â†’ DRAGGINGæµç¨‹ï¼ˆ2å°æ—¶ï¼‰

**äº¤ä»˜ç‰©ï¼š**
- Tè¿›å…¥Tapeå·¥å…·
- é¼ æ ‡hoveræ˜¾ç¤ºOn Segment
- ç‚¹å‡»é”å®šï¼Œæ‹–æ‹½ç”Ÿæˆé¢„è§ˆ

**éªŒæ”¶ï¼š**
```bash
# åŸºç¡€äº¤äº’å¯ç”¨
npm run test:tape-basic
```

---

### Day 2: Guideç”Ÿæˆå’Œæ¸²æŸ“ï¼ˆ6å°æ—¶ï¼‰

**ä»»åŠ¡ï¼š**
- [ ] Guideæ•°æ®ç»“æ„ï¼ˆ1å°æ—¶ï¼‰
- [ ] å¹³è¡Œæ–¹å‘è®¡ç®—ï¼ˆ1å°æ—¶ï¼‰
- [ ] æ— é™çº¿æ¸²æŸ“ç®—æ³•ï¼ˆ2å°æ—¶ï¼‰
- [ ] è§†è§‰æ ·å¼å®ç°ï¼ˆ2å°æ—¶ï¼‰

**äº¤ä»˜ç‰©ï¼š**
- æ‹–æ‹½ç”Ÿæˆè™šçº¿é¢„è§ˆ
- è™šçº¿æ— é™å»¶ä¼¸
- æ·¡è‰²ã€è™šçº¿æ ·å¼

**éªŒæ”¶ï¼š**
```bash
# æ¸²æŸ“æµ‹è¯•
npm run test:guide-render
```

---

### Day 3: Tapeå®Œæ•´åŠŸèƒ½ï¼ˆ6å°æ—¶ï¼‰

**ä»»åŠ¡ï¼š**
- [ ] Guide Layerå®ç°ï¼ˆ1å°æ—¶ï¼‰
- [ ] Enteræäº¤ï¼ˆ1å°æ—¶ï¼‰
- [ ] Escå–æ¶ˆé€»è¾‘ï¼ˆ1å°æ—¶ï¼‰
- [ ] è¿ç»­ç”Ÿæˆæµ‹è¯•ï¼ˆ1å°æ—¶ï¼‰
- [ ] Snapé›†æˆï¼ˆonGuideï¼‰ï¼ˆ2å°æ—¶ï¼‰

**äº¤ä»˜ç‰©ï¼š**
- å®Œæ•´Tapeå·¥å…·
- Guideå¯æŒä¹…åŒ–
- å¯snapåˆ°guide

**éªŒæ”¶ï¼š**
```bash
# å®Œæ•´åŠŸèƒ½æµ‹è¯•
npm run test:tape-full
```

---

### Day 4: åˆ†æ•°è¾“å…¥ï¼ˆ6å°æ—¶ï¼‰

**ä»»åŠ¡ï¼š**
- [ ] è¾“å…¥çŠ¶æ€æœºï¼ˆ2å°æ—¶ï¼‰
- [ ] parseLengthToMMå®ç°ï¼ˆ2å°æ—¶ï¼‰
- [ ] Space/Escè¡Œä¸ºä¿®æ­£ï¼ˆ1å°æ—¶ï¼‰
- [ ] å·¥å…·é›†æˆï¼ˆTape + DrawLineï¼‰ï¼ˆ1å°æ—¶ï¼‰

**äº¤ä»˜ç‰©ï¼š**
- åˆ†æ•°è¾“å…¥å¯ç”¨
- Spaceä¸å†æ˜¯Esc
- ç»Ÿä¸€è§£æå™¨

**éªŒæ”¶ï¼š**
```bash
# è¾“å…¥æµ‹è¯•
npm run test:fraction-input
```

---

### Day 5: UIå®Œå–„å’Œå›å½’ï¼ˆ6å°æ—¶ï¼‰

**ä»»åŠ¡ï¼š**
- [ ] Typing Overlayç»„ä»¶ï¼ˆ2å°æ—¶ï¼‰
- [ ] CSSæ ·å¼è°ƒæ•´ï¼ˆ1å°æ—¶ï¼‰
- [ ] Epicçº§å›å½’æµ‹è¯•ï¼ˆ2å°æ—¶ï¼‰
- [ ] æ–‡æ¡£æ›´æ–°ï¼ˆ1å°æ—¶ï¼‰

**äº¤ä»˜ç‰©ï¼š**
- UIå®Œæ•´
- æ‰€æœ‰DoDé€šè¿‡
- æ–‡æ¡£é½å…¨

**éªŒæ”¶ï¼š**
```bash
# å›å½’æµ‹è¯•
npm run test:epic-regression
```

---

## âœ… å®Œæˆå®šä¹‰ï¼ˆDoDï¼‰

### A. Tape Offset Guides

#### åŠŸèƒ½DoD

- [ ] **Tè¿›å…¥Tapeå·¥å…·**
  - Té”®åˆ‡æ¢
  - å·¥å…·çŠ¶æ€æ­£ç¡®

- [ ] **Hoveræ˜¾ç¤ºOn Segment**
  - ä»»æ„çº¿æ®µå¯hover
  - hoverPointå‡†ç¡®

- [ ] **ä»»æ„ç‚¹é”å®šå‚ç…§**
  - ç‚¹å‡»é”å®šanchor
  - é”šç‚¹ç¨³å®šä¸è·³å˜

- [ ] **æ‹–æ‹½ç”Ÿæˆå¹³è¡Œguide**
  - æ­£åä¸¤ä¾§æ­£ç¡®
  - è™šçº¿æ ·å¼æ˜¾ç¤º

- [ ] **æ•°å€¼è¾“å…¥æ”¯æŒ**
  - 3" / 12 1/8" / 300mm ç”Ÿæ•ˆ
  - Enteræäº¤
  - Escæ¸…è¾“å…¥

- [ ] **è¿ç»­ç”Ÿæˆ**
  - Escä¸é€€å‡ºå·¥å…·
  - å¯è¿ç»­ç”Ÿæˆå¤šä¸ªguide

---

#### ç²¾åº¦DoD

- [ ] **offsetä»¥mmå­˜å‚¨**
  - æ•°æ®ç²¾åº¦æ­£ç¡®
  - è½¬æ¢æ— è¯¯å·®

- [ ] **guideå¯é‡å¤ç”Ÿæˆ**
  - ä¸äº’ç›¸æ±¡æŸ“
  - ç‹¬ç«‹å­˜å‚¨

---

#### å›å½’DoD

- [ ] **zoomç¨³å®š**
  - zoom in/outä¸‹guideä¸æ¼‚ç§»
  - ä½ç½®ä¿æŒç›¸å¯¹å‡†ç¡®

- [ ] **æ–œçº¿æ­£ç¡®**
  - æ–œçº¿segmentå¹³è¡Œæ–¹å‘æ­£ç¡®
  - æ³•çº¿æ–¹å‘æ­£ç¡®

- [ ] **æ€§èƒ½**
  - å¿«é€Ÿæ‹–æ‹½ä¸å¡é¡¿
  - å¤šguideæ¸²æŸ“æµç•…

---

### B. Fraction Input

#### åŠŸèƒ½DoD

- [ ] **Spaceè¡Œä¸ºæ­£ç¡®**
  - Typingæ—¶Spaceå†™å…¥buffer
  - IDLEæ—¶Spaceï¼ˆå¯é€‰cancelï¼‰

- [ ] **Escè¡Œä¸ºæ­£ç¡®**
  - Typingæ—¶æ¸…buffer
  - IDLEæ—¶å–æ¶ˆæ“ä½œ

- [ ] **åˆ†æ•°è§£ææ­£ç¡®**
  - 12 1/8 = 12.125 in
  - 9'6 3/16" = 114.1875 in
  - 300mm = 300 mm

- [ ] **å·¥å…·ä¸è¢«æ‰“æ–­**
  - Tape typingä¸ä¸¢å¤±çŠ¶æ€
  - DrawLine typingä¸ä¸¢å¤±çŠ¶æ€

---

#### UI DoD

- [ ] **è¾“å…¥å¯è§**
  - å…‰æ ‡é™„è¿‘æ˜¾ç¤ºbuffer
  - INVALIDæ—¶æ˜¾ç¤ºé”™è¯¯

- [ ] **æäº¤åé¦ˆ**
  - Enteråæ¶ˆå¤±
  - ç«‹å³åº”ç”¨

---

## ğŸ§ª æµ‹è¯•ç”¨ä¾‹

### Tapeå·¥å…·æµ‹è¯•

#### TC-T001: åŸºç¡€hover
```
æ­¥éª¤ï¼š
1. Tè¿›å…¥Tapeå·¥å…·
2. é¼ æ ‡ç§»åˆ°çº¿æ®µä¸Š
3. ç§»å¼€çº¿æ®µ

æœŸæœ›ï¼š
- hoveræ—¶æ˜¾ç¤º On Segment
- ç§»å¼€åæç¤ºæ¶ˆå¤±
```

#### TC-T002: ä»»æ„ç‚¹é”å®š
```
æ­¥éª¤ï¼š
1. hoverçº¿æ®µ
2. åœ¨çº¿æ®µä¸­é—´ä»»æ„ç‚¹ç‚¹å‡»

æœŸæœ›ï¼š
- é”šç‚¹é”å®šåœ¨ç‚¹å‡»ä½ç½®
- ä¸æ˜¯ç«¯ç‚¹æˆ–ä¸­ç‚¹
```

#### TC-T003: æ‹–æ‹½ç”Ÿæˆguide
```
æ­¥éª¤ï¼š
1. é”å®šanchor
2. å‘ä¸Šæ‹–æ‹½10mm
3. å‘ä¸‹æ‹–æ‹½10mm

æœŸæœ›ï¼š
- å‘ä¸Šï¼šè™šçº¿åœ¨çº¿æ®µä¸Šæ–¹
- å‘ä¸‹ï¼šè™šçº¿åœ¨çº¿æ®µä¸‹æ–¹
- offsetæ•°å€¼æ­£ç¡®
```

#### TC-T004: è¾“å…¥è·ç¦»
```
æ­¥éª¤ï¼š
1. é”å®šanchor
2. è¾“å…¥ "3"
3. Enter

æœŸæœ›ï¼š
- ç”Ÿæˆè·ç¦»3" (76.2mm) çš„guide
- æ–¹å‘å–æ‹–æ‹½æ–¹å‘
```

#### TC-T005: åˆ†æ•°è¾“å…¥
```
æ­¥éª¤ï¼š
1. é”å®šanchor
2. è¾“å…¥ "12 1/8"
3. Enter

æœŸæœ›ï¼š
- ç”Ÿæˆè·ç¦» 12.125" (308.0mm) çš„guide
```

#### TC-T006: è¿ç»­ç”Ÿæˆ
```
æ­¥éª¤ï¼š
1. ç”Ÿæˆç¬¬ä¸€ä¸ªguide
2. Enteræäº¤
3. ä¸é€€å‡ºå·¥å…·ï¼Œå†æ¬¡hoveråŒä¸€çº¿æ®µ
4. ç”Ÿæˆç¬¬äºŒä¸ªguide

æœŸæœ›ï¼š
- ä¸¤ä¸ªguideç‹¬ç«‹å­˜åœ¨
- ä¸äº’ç›¸å¹²æ‰°
```

#### TC-T007: Escå–æ¶ˆ
```
æ­¥éª¤ï¼š
1. é”å®šanchor
2. æ‹–æ‹½
3. Esc

æœŸæœ›ï¼š
- å½“å‰guideå–æ¶ˆ
- å›åˆ°hoverçŠ¶æ€
- ä»åœ¨Tapeå·¥å…·ä¸­
```

---

### åˆ†æ•°è¾“å…¥æµ‹è¯•

#### TC-F001: Spaceä¸æ˜¯å–æ¶ˆ
```
æ­¥éª¤ï¼š
1. è¿›å…¥TypingçŠ¶æ€
2. è¾“å…¥ "12"
3. æŒ‰Space
4. è¾“å…¥ "1/8"

æœŸæœ›ï¼š
- buffer = "12 1/8"
- æ²¡æœ‰å–æ¶ˆæ“ä½œ
```

#### TC-F002: Escæ¸…buffer
```
æ­¥éª¤ï¼š
1. è¿›å…¥TypingçŠ¶æ€
2. è¾“å…¥ "123"
3. Esc

æœŸæœ›ï¼š
- bufferæ¸…ç©º
- å›åˆ°IDLE
- å·¥å…·ä¸é€€å‡º
```

#### TC-F003: å„ç§æ ¼å¼è§£æ
```
æµ‹è¯•æ•°æ®ï¼š
- "12 1/8"    â†’ 308.0mm
- "1/8"       â†’ 3.175mm
- "9'6"       â†’ 2895.6mm
- "9'-6 3/16" â†’ 2900.36mm
- "300mm"     â†’ 300mm
- "2.3m"      â†’ 2300mm

æœŸæœ›ï¼š
- å…¨éƒ¨è§£ææ­£ç¡®
- è¯¯å·® < 0.1mm
```

---

### å›å½’æµ‹è¯•

#### TC-R001: Zoomç¨³å®šæ€§
```
æ­¥éª¤ï¼š
1. ç”Ÿæˆguide
2. Zoom in 200%
3. Zoom out 50%

æœŸæœ›ï¼š
- Guideä½ç½®ä¿æŒç›¸å¯¹ç¨³å®š
- ä¸æ¼‚ç§»
```

#### TC-R002: æ–œçº¿å¹³è¡Œ
```
æ­¥éª¤ï¼š
1. åˆ›å»º45Â°æ–œçº¿
2. Tapeç”Ÿæˆå¹³è¡Œguide

æœŸæœ›ï¼š
- Guideå¹³è¡ŒäºåŸçº¿æ®µ
- æ–¹å‘æ­£ç¡®ï¼ˆ45Â°ï¼‰
```

#### TC-R003: å¤šå·¥å…·åˆ‡æ¢
```
æ­¥éª¤ï¼š
1. Tape â†’ Line
2. Line â†’ Tape
3. Tape â†’ Select

æœŸæœ›ï¼š
- å·¥å…·åˆ‡æ¢æ­£å¸¸
- çŠ¶æ€ä¸æ±¡æŸ“
```

---

## ğŸ”§ å…³é”®æ¥çº¿ç‚¹

### 1. å…¨å±€Key Routing

**ä½ç½®ï¼š** `src/app/keydown-handler.ts`

**ä¿®æ”¹ï¼š**
```typescript
// âŒ æ—§ä»£ç 
function onKeyDown(e: KeyboardEvent) {
  if (e.key === 'Space') {
    cancelCurrentOperation()  // æ€»æ˜¯å–æ¶ˆ
  }
}

// âœ… æ–°ä»£ç 
function onKeyDown(e: KeyboardEvent) {
  // ä¼˜å…ˆæ£€æŸ¥è¾“å…¥çŠ¶æ€
  if (inputState.mode === 'TYPING') {
    if (e.key === ' ') {
      appendToBuffer(' ')
      e.preventDefault()
      return
    }
    if (e.key === 'Escape') {
      clearBuffer()
      setInputState({ mode: 'IDLE' })
      e.preventDefault()
      return
    }
    if (e.key === 'Enter') {
      tryCommitTypedValue()
      e.preventDefault()
      return
    }
  }
  
  // IDLEçŠ¶æ€çš„æ­£å¸¸æŒ‰é”®å¤„ç†
  if (e.key === 'Escape') {
    cancelCurrentOperation()
  }
  // Spaceåœ¨IDLEæ—¶çš„è¡Œä¸ºï¼ˆå¯é€‰ï¼‰
  if (e.key === ' ' && ENABLE_SPACE_CANCEL) {
    cancelCurrentOperation()
  }
}
```

---

### 2. Tapeå·¥å…·é›†æˆ

**ä½ç½®ï¼š** `src/tools/tape-guide-tool.ts`

**æ–°å¢æ–‡ä»¶ï¼š**
```typescript
export class TapeGuideTool implements Tool {
  state: TapeState = { phase: 'IDLE' }
  
  onActivate() { /* Té”®è¿›å…¥ */ }
  onDeactivate() { /* é€€å‡ºå·¥å…· */ }
  
  onPointerMove(mouse: Pt) { /* hover/drag */ }
  onPointerDown(mouse: Pt) { /* lock anchor */ }
  onPointerUp(mouse: Pt) { /* å¯é€‰ */ }
  
  onTypedValue(valueMm: number, context: string) { /* æ¥æ”¶è¾“å…¥ */ }
  
  render(ctx: CanvasRenderingContext2D) { /* æ¸²æŸ“preview */ }
}
```

---

### 3. Guide Layerç®¡ç†

**ä½ç½®ï¼š** `src/store/guides-slice.ts`

**æ–°å¢ï¼š**
```typescript
interface GuidesState {
  guides: Guide[]
}

const guidesSlice = createSlice({
  name: 'guides',
  initialState: { guides: [] } as GuidesState,
  reducers: {
    addGuide(state, action: PayloadAction<Guide>) {
      state.guides.push(action.payload)
    },
    removeGuide(state, action: PayloadAction<string>) {
      state.guides = state.guides.filter(g => g.id !== action.payload)
    },
    clearGuides(state) {
      state.guides = []
    }
  }
})
```

---

### 4. Inference Engineæ‰©å±•

**ä½ç½®ï¼š** `src/inference/infer-engine.ts`

**ä¿®æ”¹ï¼š**
```typescript
// æ·»åŠ guideç›¸å…³æ¨æ–­
function infer(mouse: Pt, context: InferContext): Inference {
  const candidates = [
    inferEndpoint(mouse, context.nodes),
    inferGuideIntersection(mouse, context.guides),  // æ–°å¢
    inferMidpoint(mouse, context.segments),
    inferIntersection(mouse, context.segments),
    inferOnGuide(mouse, context.guides),  // æ–°å¢
    inferOnSegment(mouse, context.segments),
    inferGrid(mouse, context.settings)
  ].filter(Boolean)
  
  return selectBestInference(candidates)
}
```

---

## ğŸ’¬ CPOå…³é”®å¼•ç”¨

### å…³äºä¼˜å…ˆçº§
> "è¿™ä¸¤é¡¹æ˜¯'ç”»å›¾æ‰‹æ„Ÿçš„åœ°åŸº'ï¼Œæ¯”ç»§ç»­çº ç»“è§’åº¦é”æ›´èƒ½ç«‹åˆ»æå‡ä½“éªŒã€ä¹Ÿæ›´å®¹æ˜“éªŒæ”¶ã€‚"

### å…³äºScope
> "æœ¬æ¬¡åªåšä¸¤ä¸ªP0ï¼Œè§’åº¦é”æœ¬æ¬¡å†»ç»“ä¸åŠ¨ã€‚"

### å…³äºSpaceè¡Œä¸º
> "Spaceåªåœ¨IDLEæ‰èƒ½å½“å–æ¶ˆï¼Œåœ¨TYPINGå¿…é¡»æ˜¯è¾“å…¥å­—ç¬¦ã€‚è¿™æ¡è§„åˆ™æ˜¯æ ¸å¿ƒã€‚"

### å…³äºSketchUpå¯¹æ ‡
> "äº¤äº’æŒ‰SketchUpè‚Œè‚‰è®°å¿†ï¼Œä»»æ„ç‚¹é”å®šã€æ‹–æ‹½æ–¹å‘è‡ªåŠ¨åˆ¤æ–­ã€Escä¸é€€å‡ºå·¥å…·ã€‚"

---

**æ–‡æ¡£ç»´æŠ¤è€…ï¼š** CDO  
**æœ€åæ›´æ–°ï¼š** 2026-02-03  
**ç‰ˆæœ¬ï¼š** v1.0  
**çŠ¶æ€ï¼š** âœ… Ready for Implementation
