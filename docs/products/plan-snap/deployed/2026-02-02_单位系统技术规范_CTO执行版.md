# 单位系统技术规范 - CTO 执行版

> **会议时间：** 2026-02-02  
> **参与人：** CEO, CPO, COO  
> **整理人：** CDO  
> **优先级：** 🔴 Critical - 架构级决策  
> **状态：** ✅ 已确认，立即执行  
> **预计工作量：** 2-3天（架构封印）

---

## 🎯 核心决策（CEO + COO + CPO 共识）

### 一句话结论

> **底层数据统一用 mm，UI 层一键切换英制/公制。**  
> **北美用户感觉不到底层 mm，用起来还是他们熟悉的 inch and foot。**

**这是专业 CAD/BIM 软件的标准做法，也是唯一正确路线。**

---

## ⚠️ 为什么是 mm？（工业级共识）

### 不是偏好，是工程必然

**为什么不是 inch？**
```
inch/foot 是非十进制
9'6" = 114.3 mm（不是整数）
累积计算（面积/takeoff/ISO）误差会越来越大
```

**为什么不是 cm/m？**
```
cm 精度不够
m 会有小数
→ mm = 唯一不会后悔的选择
```

---

### 行业背书

**所有专业 CAD 内部都用 mm 或米：**
- ✅ AutoCAD（内部 mm）
- ✅ Revit（内部 mm）
- ✅ SketchUp（内部 inch，但也是统一单位）
- ✅ IFC / BIM 数据标准
- ✅ CNC / 加工 / 工厂图

**结论：** 所有"看起来像英制"的 CAD，本质都在用统一单位

---

## 🏗️ 正确的分层架构

### 三层精度模型

```
┌─────────────────────────────────────┐
│    [ UI Layer ]                      │
│    - 输入解析（9'6, 114", 2.3m）    │
│    - 显示格式（9'-6", 114", 2.300m）│
├─────────────────────────────────────┤
│    [ Measurement Adapter ]           │
│    - imperial (ft/in)                │
│    - metric (mm/cm/m)                │
├─────────────────────────────────────┤
│    [ Core Geometry Engine ]          │
│    - mm (唯一真实单位)              │
│    - 连续浮点数，不 round            │
└─────────────────────────────────────┘
```

**关键原则：**
> Grid 只是"参考线"，不是几何约束

---

## 📐 1/16" 精度要求

### CEO 的问题

> "如果我想尺寸精确到 1/16"，对我们的 Grid 系统有什么要求？"

---

### 关键换算

```
1 inch = 25.4 mm
1/16" = 1.5875 mm
1/32" = 0.79375 mm
```

**结论：** 几何系统必须能稳定处理 ~0.8 mm 级别的精度

---

### 三层精度概念（重要）

```
[ Geometry Precision ]  ← 连续 mm（float/double）
        ↑
[ Snap Precision ]      ← 1/16" / 1/8" / off
        ↑
[ Grid Display ]        ← 视觉参考
```

**关键：**
```
❌ Grid ≠ 几何精度
✅ Grid 只是"参考线"，不是几何约束
```

---

### ❌ 错误做法（新手 CAD 常犯）

```typescript
// ❌ 错误：强制所有点落在 Grid 上
Grid spacing = 1/16"
所有点强制 snap 到 grid
所有几何坐标 = grid × N

// 后果：
// - 斜线/ISO/midpoint 误差爆炸
// - 多次操作后几何畸变
// - 以后做 takeoff/area 会出 bug
```

---

### ✅ 正确做法（AutoCAD/SketchUp 路线）

```typescript
// ✅ 正确：连续几何 + 可选吸附

// 1. 底层几何（最重要）
type Millimeter = number;

interface Point {
  x: Millimeter;  // 连续值，如 2895.6
  y: Millimeter;  // 不 round，不 clamp
}

// 2. Snap 系统（用户感觉到"精确"）
enum SnapMode {
  OFF = 'off',
  FINE = '1/16"',      // 1.5875 mm
  MEDIUM = '1/8"',     // 3.175 mm
  COARSE = '1/4"'      // 6.35 mm
}

function snapValue(mm: number, stepMm: number): number {
  return Math.round(mm / stepMm) * stepMm;
}

// 3. Grid Display（视觉层）
const GRID_DISPLAY = {
  major: 304.8,      // 1 ft
  minor: 152.4,      // 6"
  fine: 25.4,        // 1"
  // 不画 1/16"（屏幕上不可见）
};
```

---

## 📋 输入解析（支持混合输入）

### 用户真实输入行为

```
9'6
9'-6"
114"
2.9m
2900
2900mm
```

**原则：** 输入时不强制单位，自动识别 → 转 mm

---

### 解析规则

| 输入 | 解析 | 内部 (mm) |
|------|------|-----------|
| `9'6` | 9 ft 6 in | 2895.6 |
| `9'-6"` | 9 ft 6 in | 2895.6 |
| `114"` | 114 inches | 2895.6 |
| `2.9m` | 2.9 meters | 2900 |
| `2900mm` | 2900 mm | 2900 |
| `2900` | 假定当前 UI 单位 | 2900 (如果是 mm) |

---

### 实现：parseLengthToMM()

```typescript
// /packages/core/src/units/parseLengthToMM.ts

const INCH_TO_MM = 25.4;

export function parseLengthToMM(
  input: string,
  defaultUnit: 'imperial' | 'metric' = 'imperial'
): Millimeter {
  const trimmed = input.trim().toLowerCase();
  
  // 1. Imperial: feet + inches
  // 支持：9'6, 9'-6", 9' 6", 9'6"
  const imperialMatch = trimmed.match(/^(\d+)'?\s*(\d+)?\"?$/);
  if (imperialMatch) {
    const feet = parseInt(imperialMatch[1]) || 0;
    const inches = parseInt(imperialMatch[2]) || 0;
    return (feet * 12 + inches) * INCH_TO_MM;
  }
  
  // 2. Inches only
  // 支持：114", 114
  const inchMatch = trimmed.match(/^(\d+\.?\d*)\"$/);
  if (inchMatch) {
    return parseFloat(inchMatch[1]) * INCH_TO_MM;
  }
  
  // 3. Meters
  // 支持：2.9m, 2.9M
  const meterMatch = trimmed.match(/^(\d+\.?\d*)m$/);
  if (meterMatch) {
    return parseFloat(meterMatch[1]) * 1000;
  }
  
  // 4. Millimeters
  // 支持：2900mm, 2900MM
  const mmMatch = trimmed.match(/^(\d+\.?\d*)mm$/);
  if (mmMatch) {
    return parseFloat(mmMatch[1]);
  }
  
  // 5. 纯数字：根据当前 UI 单位
  const numMatch = trimmed.match(/^(\d+\.?\d*)$/);
  if (numMatch) {
    const value = parseFloat(numMatch[1]);
    if (defaultUnit === 'imperial') {
      return value * INCH_TO_MM;  // 假定 inches
    } else {
      return value;  // 假定 mm
    }
  }
  
  throw new Error(`Invalid length format: ${input}`);
}
```

---

### 单元测试（必须通过）

```typescript
// /packages/core/src/units/parseLengthToMM.test.ts

describe('parseLengthToMM', () => {
  it('parses imperial feet-inches', () => {
    expect(parseLengthToMM("9'6")).toBeCloseTo(2895.6, 1);
    expect(parseLengthToMM("9'-6\"")).toBeCloseTo(2895.6, 1);
    expect(parseLengthToMM("9' 6\"")).toBeCloseTo(2895.6, 1);
  });
  
  it('parses inches only', () => {
    expect(parseLengthToMM('114"')).toBeCloseTo(2895.6, 1);
  });
  
  it('parses meters', () => {
    expect(parseLengthToMM('2.9m')).toBe(2900);
  });
  
  it('parses millimeters', () => {
    expect(parseLengthToMM('2900mm')).toBe(2900);
  });
  
  it('parses pure numbers with default unit', () => {
    expect(parseLengthToMM('114', 'imperial')).toBeCloseTo(2895.6, 1);
    expect(parseLengthToMM('2900', 'metric')).toBe(2900);
  });
});
```

---

## 📊 显示格式（北美用户友好）

### Imperial 显示规则（非常重要）

**永远显示为 `x'-y"`，不要只显示 inch**

```
❌ 114"
✅ 9'-6"
```

**这是北美施工现场肌肉记忆**

---

### 显示规则

```typescript
// /packages/core/src/units/formatLength.ts

export function formatImperial(
  mm: Millimeter,
  precision: '1/16"' | '1/8"' | '1/4"' = '1/16"'
): string {
  const totalInches = mm / INCH_TO_MM;
  
  // 1. 分离 feet 和 inches
  const feet = Math.floor(totalInches / 12);
  let inches = totalInches % 12;
  
  // 2. Round 到指定精度
  const roundTo = {
    '1/16"': 1/16,
    '1/8"': 1/8,
    '1/4"': 1/4
  }[precision];
  
  inches = Math.round(inches / roundTo) * roundTo;
  
  // 3. 处理进位（如果 inches 达到 12）
  if (inches >= 12) {
    feet += 1;
    inches -= 12;
  }
  
  // 4. 格式化
  if (feet > 0 && inches > 0) {
    return `${feet}'-${formatInches(inches)}"`;
  } else if (feet > 0) {
    return `${feet}'-0"`;
  } else {
    return `${formatInches(inches)}"`;
  }
}

function formatInches(inches: number): string {
  // 处理分数（如果需要）
  const whole = Math.floor(inches);
  const frac = inches - whole;
  
  if (frac === 0) {
    return whole.toString();
  }
  
  // 简化分数（1/16, 1/8, 1/4）
  const sixteenths = Math.round(frac * 16);
  if (sixteenths === 0) {
    return whole.toString();
  }
  
  // 简化
  const gcd = (a: number, b: number): number => b === 0 ? a : gcd(b, a % b);
  const divisor = gcd(sixteenths, 16);
  const num = sixteenths / divisor;
  const den = 16 / divisor;
  
  if (whole > 0) {
    return `${whole} ${num}/${den}`;
  } else {
    return `${num}/${den}`;
  }
}

export function formatMetric(
  mm: Millimeter,
  precision: '1mm' | '5mm' | '10mm' = '1mm'
): string {
  const roundTo = {
    '1mm': 1,
    '5mm': 5,
    '10mm': 10
  }[precision];
  
  const rounded = Math.round(mm / roundTo) * roundTo;
  
  // 显示为 m（如果 ≥ 1000mm）或 mm
  if (rounded >= 1000) {
    return `${(rounded / 1000).toFixed(3)} m`;
  } else {
    return `${rounded} mm`;
  }
}
```

---

### 显示测试

```typescript
describe('formatImperial', () => {
  it('formats feet-inches correctly', () => {
    expect(formatImperial(2895.6)).toBe("9'-6\"");
    expect(formatImperial(304.8)).toBe("1'-0\"");
    expect(formatImperial(25.4)).toBe("1\"");
  });
  
  it('rounds to specified precision', () => {
    expect(formatImperial(2896, '1/16"')).toBe("9'-6\"");
    expect(formatImperial(2896, '1/8"')).toBe("9'-6\"");
  });
});
```

---

## 🔄 UI 单位切换

### 状态模型

```typescript
// /packages/core/src/types/index.ts

type UnitSystem = 'imperial' | 'metric';

type Precision = 
  | '1/16"' | '1/8"' | '1/4"'   // imperial
  | '1mm' | '5mm' | '10mm';     // metric

interface UISettings {
  unitSystem: UnitSystem;
  precision: Precision;
  snapMode: SnapMode;
}
```

---

### 切换时发生什么

```typescript
// /packages/core/src/state/settingsReducer.ts

function switchUnitSystem(
  state: AppState,
  newSystem: UnitSystem
): AppState {
  // ❌ 不改数据库
  // ❌ 不改 geometry
  
  // ✅ 只影响：
  return {
    ...state,
    ui: {
      ...state.ui,
      unitSystem: newSystem,
      // 更新默认精度
      precision: newSystem === 'imperial' ? '1/16"' : '1mm',
    }
  };
  
  // 触发：
  // - 尺寸标注重新渲染
  // - 输入 placeholder 更新
  // - Grid 显示更新（可选）
}
```

---

### 关键：几何数据不变

```typescript
// 验证测试（必须通过）
it('geometry must not change when UI unit switches', () => {
  // 1. 画一条线（imperial）
  setState({ ui: { unitSystem: 'imperial' } });
  const lineId = drawLine("9'6\"");
  const lengthBefore = getLineLengthMm(lineId);
  
  // 2. 切换到 metric
  switchUnitSystem('metric');
  const lengthAfter = getLineLengthMm(lineId);
  
  // 3. 验证：几何数据完全不变
  expect(lengthAfter).toBeCloseTo(lengthBefore, 5);
  expect(lengthAfter).toBeCloseTo(2895.6, 1);
});
```

---

## 🚨 当前状态评估

### CEO 的问题

> "我们现在是标准已经是 MM 了吗？要不要让 CTO 做点什么？"

---

### CPO 的判断

**现在 90% 的概率：**
```
✅ 表面上是 mm
❌ 体系上还没真正锁死 mm
```

**必须让 CTO 做一次"单位一致性清查 + 技术封印"**

---

### 常见状态（你们可能是这样）

```
✅ 数据库字段叫 width_mm / height_mm
✅ 口头共识是"内部用 mm"

❌ 前端某些地方还在用 inch/ft 做中间计算
❌ grid / snap / 输入解析 / 显示混在一起
❌ 没有任何代码层面的"禁止使用非 mm"机制
```

**这种状态：** 短期完全没问题，半年后一定返工

---

### 不做会发生什么（真实事故）

#### ❌ 场景 1：Takeoff 出现 1-2% 误差

```
一部分边长被提前 round 成 1/16"
面积算出来和人工算的不一致
会计/工程师不信系统
```

#### ❌ 场景 2：ISO/平面/3D 对不上

```
平面图看着没问题
ISO 图偏 3-5mm
用户怀疑"AI 算错了"
```

#### ❌ 场景 3：某个前端新人用 inch 写了 helper

```typescript
// ❌ 错误示例
const INCH = 25.4;
// 然后在另一个地方又转了一次……
// Bug 非常隐蔽，排查成本极高
```

---

## ✅ CTO 必须执行的任务清单

### 重要性

**这不是"多做点功能"，而是架构封印级别的事情。**

---

### Task 1：明确并写死「单位宪法」🔴

**位置：** 代码仓库根目录（`README.md` 或 `docs/units.md`）

**内容：**

```markdown
## Units Policy (Hard Rule)

- **All geometry and measurements are stored in millimeters (mm).**
- **No other unit is allowed in core geometry, state, or persistence.**
- **UI units (imperial / metric) are view-layer only.**
- **User input must be parsed into mm immediately.**
- **Display rounding must never affect stored values.**

This is a **technical constitution**, not a suggestion.
Violations will cause bugs in takeoff, ISO, and area calculations.
```

**验收：**
- [ ] 文档已创建
- [ ] 全团队已阅读并确认

---

### Task 2：类型层面「封印 mm」🔴

**问题：** 裸 `number` 无法表达语义

```typescript
// ❌ 不好：无法区分是 mm 还是 inch
let width = 3000;
```

**解决：** 使用语义类型

```typescript
// ✅ 好：明确是 mm
type Millimeter = number;

interface Point {
  x: Millimeter;
  y: Millimeter;
}

interface Line {
  id: string;
  startNodeId: string;
  endNodeId: string;
  lengthMm: Millimeter;  // 明确标注
}
```

**验收：**
- [ ] 所有几何类型使用 `Millimeter`
- [ ] 所有长度字段后缀 `Mm` 或使用 `Millimeter` 类型

---

### Task 3：严禁任何地方出现 inch/ft 常量🔴

**问题：** 单位换算散落各处

```typescript
// ❌ 禁止：到处都是魔法数字
const INCH = 25.4;
const FOOT = 304.8;
```

**解决：** 单位换算集中管理

```typescript
// ✅ 只能存在于一个地方
// /packages/core/src/units/imperial.ts

const INCH_TO_MM = 25.4;
const FOOT_TO_MM = 304.8;

export function inchToMm(inch: number): Millimeter {
  return inch * INCH_TO_MM;
}

export function footToMm(foot: number): Millimeter {
  return foot * FOOT_TO_MM;
}

export function mmToInch(mm: Millimeter): number {
  return mm / INCH_TO_MM;
}

export function mmToFoot(mm: Millimeter): number {
  return mm / FOOT_TO_MM;
}

export function parseImperial(input: string): Millimeter {
  return parseLengthToMM(input, 'imperial');
}

export function formatImperial(mm: Millimeter, precision?: string): string {
  // ...
}
```

**验收：**
- [ ] 所有单位换算都在 `units/` 目录
- [ ] 其他地方没有 `25.4` 或 `304.8` 魔法数字
- [ ] 使用 ESLint 规则禁止（可选）

---

### Task 4：Snap / Grid / Geometry 解耦检查🔴

**CTO 需要确认下面三件事是独立模块：**

| 模块 | 单位 | 职责 |
|------|------|------|
| GeometryEngine | mm | 几何计算，连续值 |
| SnapManager | mm | 吸附逻辑，可选精度 |
| GridRenderer | 视觉 | 显示参考线 |

---

**检查清单：**

```typescript
// ❌ 错误：Grid step 被直接用来算坐标
const point = {
  x: Math.round(mouseX / gridStep) * gridStep,
  y: Math.round(mouseY / gridStep) * gridStep
};

// ✅ 正确：Grid 只影响显示，snap 是独立逻辑
const point = {
  x: mouseX,  // 连续值
  y: mouseY
};

// 仅在需要时 snap
if (snapMode !== 'off') {
  point.x = snapValue(point.x, snapStepMm);
  point.y = snapValue(point.y, snapStepMm);
}
```

**验收：**
- [ ] Grid 渲染不影响几何坐标
- [ ] Snap 是独立的可选逻辑
- [ ] 几何引擎完全不知道 Grid 存在

---

### Task 5：加一个「单元测试地雷」🔴

**目的：** 防止架构污染

```typescript
// /packages/core/src/units/units.test.ts

describe('Units System Integrity', () => {
  it('geometry must not change when UI unit switches', () => {
    // 1. Imperial 模式画线
    setState({ ui: { unitSystem: 'imperial' } });
    const lineId = drawLine("9'6\"");
    const lengthBefore = getLineLengthMm(lineId);
    
    // 2. 切换到 Metric
    switchUnitSystem('metric');
    const lengthAfter = getLineLengthMm(lineId);
    
    // 3. 验证：几何完全不变
    expect(lengthAfter).toBeCloseTo(lengthBefore, 5);
    expect(lengthAfter).toBeCloseTo(2895.6, 1);
  });
  
  it('snap precision does not affect geometry storage', () => {
    // 1. Fine snap (1/16")
    setSnapMode('FINE');
    const p1 = createPoint(100.5, 200.7);  // 不是 1/16" 倍数
    
    // 2. 切换到 Coarse snap (1/4")
    setSnapMode('COARSE');
    const p1After = getPoint(p1.id);
    
    // 3. 验证：存储的坐标不变
    expect(p1After.x).toBe(100.5);
    expect(p1After.y).toBe(200.7);
  });
  
  it('grid display does not affect geometry', () => {
    const line = drawLine("9'6\"");
    
    // 改变 Grid 设置
    setGridSize(1);    // 1 ft
    const len1 = getLineLengthMm(line);
    
    setGridSize(0.5);  // 6 in
    const len2 = getLineLengthMm(line);
    
    // 验证：长度不变
    expect(len1).toBe(len2);
  });
});
```

**验收：**
- [ ] 所有测试通过
- [ ] 测试在 CI/CD 中运行
- [ ] 测试失败会阻止 PR 合并

---

### Task 6：代码审查清单🟡

**CTO 需要审查现有代码：**

```typescript
// 审查清单

// ❌ 查找所有 25.4 / 304.8 魔法数字
grep -r "25.4" src/
grep -r "304.8" src/

// ❌ 查找所有可疑的单位变量
grep -ri "inch\|foot\|feet" src/
// 只应该在 units/ 目录出现

// ❌ 查找所有可能的单位混用
grep -r "* 25.4\|/ 25.4" src/
// 应该用 inchToMm() 或 mmToInch()

// ✅ 确认所有几何字段
// 应该命名为 widthMm, lengthMm
// 或使用 Millimeter 类型
```

**验收：**
- [ ] 清查完成
- [ ] 问题已修复
- [ ] 形成清查报告

---

## 📊 实施计划

### Phase 1: 文档和规范（0.5天）

- [ ] 创建 `docs/units.md`（单位宪法）
- [ ] 定义 `Millimeter` 类型
- [ ] 创建 `units/` 目录结构

---

### Phase 2: 核心实现（1天）

- [ ] 实现 `parseLengthToMM()`
- [ ] 实现 `formatImperial()` 和 `formatMetric()`
- [ ] 实现单位换算函数
- [ ] 编写单元测试

---

### Phase 3: 解耦和封印（1天）

- [ ] 解耦 Snap / Grid / Geometry
- [ ] 移除所有魔法数字
- [ ] 更新所有类型定义
- [ ] 代码审查和清查

---

### Phase 4: 集成测试（0.5天）

- [ ] 单位切换测试
- [ ] Snap 精度测试
- [ ] Grid 显示测试
- [ ] 端到端测试

---

**总工作量：** 2-3天

---

## ✅ 最终验收标准

### CEO 判断信号

**CEO 只需要问 CTO 一句话：**

> "我们现在有没有任何地方，用 inch/ft 作为中间计算单位？"

---

### 合格答案

**CTO 立刻说：**
```
"没有。所有单位换算都在 units/ 目录，
所有几何都是 mm，
有类型系统保障，
有单元测试覆盖。"
```

---

### 不合格答案

**CTO 说：**
```
"应该没有吧，但我再看看"
```

**→ 那就必须做这一步封印！**

---

## 🎯 完成后你们会得到什么

### 技术收益

```
✅ 英制/公制随便切换
✅ 1/16" / 1/8" / metric 精度随便调
✅ ISO / takeoff / AI 全部复用同一套几何
✅ 新人加入不敢乱写
✅ 面积/长度计算永远准确
```

---

### 产品信心

```
✅ 北美用户：看到熟悉的 9'-6"
✅ 国际用户：可以切换到 metric
✅ 工程师：数据精确可靠
✅ 团队：架构清晰稳定
```

---

### 商业价值

```
✅ 可以自信地卖给专业用户
✅ Takeoff 功能可以直接加
✅ ISO / 3D 可以无缝对接
✅ 没有隐藏的技术债
```

---

## 📎 相关文档

**已有文档：**
- PlanSnap 产品设计蓝图
- PlanSnap CAD 风格改进技术方案
- Sprint 1 技术任务清单

**新增文档：**
- 单位系统技术规范（本文档）
- 单位转换 API 文档（待创建）

---

## 💡 CPO 的核心洞察

### 为什么这一步不做，将来会发生什么

**真实事故预警：**

```
❌ Takeoff 误差 1-2%
❌ ISO/平面图对不上
❌ 新人写了 bug，排查极难
❌ 用户不信任系统精度
❌ 返工成本极高
```

---

### 这是 CAD 产品负责人的判断

**普通产品经理：**
```
"要不要支持英制？"
```

**你们（CEO + COO + CPO）：**
```
"底层统一 mm，UI 切换即可。"
```

**这已经是 AutoCAD / Revit 级别的架构思维。**

---

## 🎓 给 CTO 的话

### CPO 的评价

> "这是技术宪法，不是建议。"  
> "把'单位换算'集中关进一个笼子里。"

---

### CEO 的期待

> "这一步做完，我们就有了专业 CAD 的底层基础。"

---

### CDO 的提醒

> "这 2-3 天的工作，会为未来省下 2-3 个月的返工。"

---

**版本：** v1.0  
**创建时间：** 2026-02-02  
**状态：** ✅ 已确认，立即执行  
**优先级：** 🔴 Critical - 架构级决策  

---

**CTO，这是一份可以直接执行的技术规范。请按照任务清单逐项完成，完成后 PlanSnap 和 IsoSnap 将拥有专业 CAD 级别的单位系统。** 🚀
